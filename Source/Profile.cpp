//------------------------------------------------------------------------------
//	Originally written by Taron Millet, except where otherwise noted
//------------------------------------------------------------------------------

#include "Profile.h"

#include "Dialogs.h"
#include "Resources/resource.h"

#include <fstream>

namespace Profile
{

//------------------------------------------------------------------------------
// Const Data
//------------------------------------------------------------------------------

enum {
kINIFileBufferSize = 4096, // How many chars to process at a time from .ini
kVarsSectionIdx = 0,
kUIScaleVarID = 0,
kWidthVarID = 1,
kHeightVarID = 2,
};

const char* kProfileFileNamePrefix = "MMOGO_";
const char* kProfileFileNameSuffix = ".ini";
const char* kProfileKeyPrefix = "Profile";
const char* kCoreProfileName = "MMOGO_Core.ini";
const char* kBaseGameSettingsSection = "System";
const char* kAutoLaunchAppKey = "AutoLaunchApp";
const char* kAutoLaunchAppParamsKey = "AutoLaunchAppParams";
const char* kKnownIssuesKey = "KnownIssues";
const char* kAutoLoadProfileKey = "AutoLoadProfile";
const char* kAutoGenVersionKey = "AutoGeneratedVersion";
const char* kVariablesSectionName = "Variables";
const char* kUIScaleVarName = "UIScale";
const char* kWidthVarName = "W";
const char* kHeightVarName = "H";
const std::string kEndOfLine = "\r\n";

struct ResourceFile
{
	const char* dispName;
	const char* fileName;
	WORD resID;
	int version;
};

const ResourceFile kResTemplateCore =
	{	"Core",				"Core",				IDR_TEXT_INI_CORE,		11	};

const ResourceFile kResTemplateBase[] =
{//		dispName			fileName			resID					ver
	{	"AOA Base",			"AOA Base",			IDR_TEXT_INI_BASE_AOA,	11	},
	{	"EQ P99 Base",		"P99 Base",			IDR_TEXT_INI_BASE_P99,	9	},
	{	"EQ PQ Base",		"PQ Base",			IDR_TEXT_INI_BASE_PQ,	9	},
	{	"M&M Base",			"MnM Base",			IDR_TEXT_INI_BASE_MNM,	12	},
	{	"Pantheon Base",	"Pantheon Base",	IDR_TEXT_INI_BASE_PAN,	10	},
};

const ResourceFile kResTemplateDefault[] =
{//		dispName			fileName			resID					ver
	{	"AOA Default",		"AOA Default",		IDR_TEXT_INI_DEF_AOA,	12	},
	{	"EQ P99 Default",	"P99 Default",		IDR_TEXT_INI_DEF_P99,	10	},
	{	"EQ PQ Default",	"PQ Default",		IDR_TEXT_INI_DEF_PQ,	10	},
	{	"M&M Default",		"MnM Default",		IDR_TEXT_INI_DEF_MNM,	12	},
	{	"Pantheon Default",	"Pantheon Default",	IDR_TEXT_INI_DEF_PAN,	11	},
};

const ResourceFile kResTemplateCustom[] =
{//		dispName						fileName	resID					ver
	{	"Adrullan Online Adventures",	"AOA",		IDR_TEXT_INI_CUST_AOA,	0 },
	{	"EverQuest: Project 1999",		"P99",		IDR_TEXT_INI_CUST_P99,	0 },
	{	"EverQuest: Project Quarm",		"PQ",		IDR_TEXT_INI_CUST_PQ,	0 },
	{	"Monsters & Memories",			"MnM",		IDR_TEXT_INI_CUST_MNM,	0 },
	{	"Pantheon: Rise of the Fallen",	"Pantheon",	IDR_TEXT_INI_CUST_PAN,	0 },
};

const ResourceFile kResTemplateBlank = { "", "", IDR_TEXT_INI_CUST_BLANK, 0 };

enum EParseMode
{
	eParseMode_Header,
	eParseMode_Sections,
	eParseMode_Full,
};

struct ProfileFile
{
	std::string name;
	std::string path;
};

struct ProfileInfo
{
	std::string name;
	std::vector<int> fileIDs;
	bool valid() { return !fileIDs.empty(); }
};

typedef void (*ParseINICallback)(
	const std::string& theSection,
	const std::string& theName,
	const std::string& theValue,
	void* theUserData);

struct ZERO_INIT(UnsavedProperty)
{
	int sectionID;
	int propertyID;
	std::string value;
};

struct ZERO_INIT(VarPropDependency)
{
	u32 varID : 9;
	u32 sectID : 9;
	u32 propID : 14;

	u32 cmpVal() const { return (varID << 23) | (sectID << 14) | propID; }
    bool operator<(const VarPropDependency& rhs) const
	{ return cmpVal() < rhs.cmpVal(); }
    bool operator==(const VarPropDependency& rhs) const
	{ return cmpVal() == rhs.cmpVal(); }
};

struct BaseGameSettings
{
	struct AutoLaunch
	{
		std::string path;
		std::string params;
	} autoLaunch;
	std::string knownIssuesList;
};


//------------------------------------------------------------------------------
// Static Variables
//------------------------------------------------------------------------------

static SectionsMap sSectionsMap;
static SectionsMap sChangedSectionsMap;
static std::vector<UnsavedProperty> sUnsavedChangesList;
static std::vector<ProfileFile> sKnownFiles;
static std::vector<ProfileInfo> sProfiles; // index 0 is a dummy/reserved entry
static std::vector<VarPropDependency> sVarPropDepList;
static std::string sLoadedProfileName;
static std::string sKnownIssuesRTF;
static bool sNeedShowKnownIssues = false;
static int sAutoLoadProfileID = 0;
static int sNewBaseProfileIdx = -1;


//------------------------------------------------------------------------------
// Debugging
//------------------------------------------------------------------------------

#ifndef NDEBUG
static int sPropertyMapPtrCount = 0;
PropertyMapPtr::PropertyMapPtr(const PropertyMap* ptr)
: ptr(ptr) { ++sPropertyMapPtrCount; }
PropertyMapPtr::PropertyMapPtr(const PropertyMapPtr& rhs)
: ptr(rhs.ptr) { ++sPropertyMapPtrCount; }
PropertyMapPtr::~PropertyMapPtr()
{ --sPropertyMapPtrCount; }
PropertyMapPtr& PropertyMapPtr::operator=(const PropertyMapPtr& rhs)
{ ptr = rhs.ptr; return *this; }
const PropertyMap* PropertyMapPtr::operator->() const { return ptr; }
const PropertyMap& PropertyMapPtr::operator*() const { return *ptr; }
PropertyMapPtr::operator const PropertyMap*() const { return ptr; }
inline static void confirmSafeToWriteToMap()
{ DBG_ASSERT(sPropertyMapPtrCount == 0); }
#else
inline static void confirmSafeToWriteToMap() {}
#endif


//------------------------------------------------------------------------------
// Local Functions
//------------------------------------------------------------------------------

static const std::string& iniFolderPath()
{
	static std::string sFolderPath;
	if( sFolderPath.empty() )
	{
		// Just use our application folder (for now)
		sFolderPath = getAppFolder();

		// Make sure it actually exists
		// (obviously it has to, but leaving this here for possibly
		// later changing the .ini folder to AppData or something)
		size_t aCurPos = 0;
		for(;;)
		{
			size_t aSlashPos = sFolderPath.find_first_of("\\/", aCurPos);
			if( aSlashPos == std::string::npos )
			{
				_wmkdir(widen(sFolderPath).c_str());
				break;
			}

			aCurPos = aSlashPos + 1;

			std::string aCurPath = sFolderPath.substr(0, aSlashPos);
			_wmkdir(widen(aCurPath).c_str());
		}
	}

	return sFolderPath;
}


static std::string extractProfileName(const std::string& theString)
{
	std::string result = removeExtension(getFileName(theString));
	const std::string& prefix = upper(kProfileFileNamePrefix);
	if( upper(result).compare(0, prefix.length(), upper(prefix)) == 0 )
		result = result.substr(prefix.length());
	return replaceChar(result, '_', ' ');
}


static std::string profileNameToFilePath(const std::string& theName)
{
	DBG_ASSERT(theName == extractProfileName(theName));
	std::string result = iniFolderPath();
	result += kProfileFileNamePrefix;
	result += replaceChar(theName, ' ', '_');
	result += kProfileFileNameSuffix;
	return result;
}


static bool fileExists(const std::string& theFilePath)
{
	return isValidFilePath(theFilePath);
}


static bool fileExists(const ProfileFile& theFile)
{
	return fileExists(theFile.path);
}


static ProfileFile profileNameToFile(const std::string& theProfileName)
{
	ProfileFile aFileInfo;
	aFileInfo.name = extractProfileName(theProfileName);
	aFileInfo.path = profileNameToFilePath(aFileInfo.name);
	return aFileInfo;
}


static int getOrAddKnownFileID(const ProfileFile& theFileInfo)
{
	// A map would be faster, but requires a separate Map structure
	// to ensure stable indexes (or using pointers instead), and
	// there's unlikely to be a whole lot of these anyway.
	for(int i = 0, end = intSize(sKnownFiles.size()); i < end; ++i)
	{
		if( isSamePath(sKnownFiles[i].path, theFileInfo.path) )
			return i;
	}

	sKnownFiles.push_back(theFileInfo);
	return intSize(sKnownFiles.size()) - 1;
}


static void parseINI(
	ParseINICallback theCallbackFunc,
	const std::string& theFilePath,
	EParseMode theParseMode,
	void* theUserData = NULL)
{
	std::ifstream aFile(widen(theFilePath).c_str(), std::ios::binary);
	if( !aFile.is_open() )
	{
		logFatalError("Could not open file %s", theFilePath.c_str());
		return;
	}

	// Prepare input buffer
	// +1 on size is to accommodate an extra newline character when
	// reach end of file
	char aBuffer[kINIFileBufferSize+1];
	std::streamsize aBufferSize = kINIFileBufferSize;
	std::string aNewSection;
	std::string aSection;
	std::string aKey;
	std::string aValue;

	enum
	{
		ePIState_Whitespace,
		ePIState_Section,
		ePIState_Key,
		ePIState_Value,
		ePIState_Comment,
	} aState = ePIState_Whitespace;

	while(aFile.good())
	{
		// Read next chunk from file
		aFile.read(aBuffer, aBufferSize);
		if( aFile.eof() || aFile.gcount() < aBufferSize )
		{// Put eol at end of file in case there wasn't one already
			aBufferSize = aFile.gcount() + 1;
			aBuffer[aBufferSize-1] = '\n';
			DBG_ASSERT(aBufferSize <= ARRAYSIZE(aBuffer));
		}
		else if( aFile.bad() )
		{
			logFatalError("Unknown error reading %s", theFilePath.c_str());
			aFile.close();
			return;
		}

		for(int i = 0; i < aBufferSize; ++i)
		{// Step through buffer character-by-character
			const char c = aBuffer[i];
			switch(aState)
			{
			case ePIState_Whitespace:
				// Look for a section, key, or comment
				if( c == '[' )
				{
					if( theParseMode == eParseMode_Header )
					{// Stop parsing once hit [ in this mode
						aFile.close();
						return;
					}
					aState = ePIState_Section;
					aNewSection.clear();
				}
				else if( c == '#' || c == ';' )
				{
					aState = ePIState_Comment;
				}
				else if( u8(c) > ' ' )
				{
					if( theParseMode == eParseMode_Sections &&
						aSection.empty() )
					{// Treat anything before first section as a comment
						aState = ePIState_Comment;
					}
					else
					{
						aState = ePIState_Key;
						aKey.clear();
						aKey.push_back(c);
					}
				}
				break;

			case ePIState_Section:
				// Look for end of line after ']' to end section
				switch(c)
				{
				case '\r': case '\n': case '\0':
					aNewSection = trim(aNewSection);
					if( aNewSection.size() > 1 &&
						aNewSection[aNewSection.size()-1] == ']' )
					{
						aNewSection.resize(aNewSection.size()-1);
						aSection.swap(aNewSection);
					}
					aState = ePIState_Whitespace;
					break;
				default:
					aNewSection.push_back(c);
				}
				break;

			case ePIState_Key:
				// Look for '=' to end key
				if( c == '=' )
				{// Switch from parsing key to value
					aKey = trim(aKey);
					aState = ePIState_Value;
					aValue.clear();
				}
				else if( c == '\r' || c == '\n' || c == '\0' )
				{// Abort - invalid key
					aState = ePIState_Whitespace;
				}
				else
				{
					aKey.push_back(c);
				}
				break;

			case ePIState_Value:
				// Look for eol to end value
				if( c == '\r' || c == '\n' || c == '\0' )
				{// Value string complete, time to process it!
					aValue = trim(aValue);
					theCallbackFunc(aSection, aKey, aValue, theUserData);
					aState = ePIState_Whitespace;
				}
				else
				{
					aValue.push_back(c);
				}
				break;

			case ePIState_Comment:
				// Look for eol to end comment
				if( c == '\r' || c == '\n' || c == '\0' )
					aState = ePIState_Whitespace;
				break;
			}
		}
	}

	aFile.close();
}


static void setPropertyInINI(
	const std::string& theFilePath,
	const std::string& theSection,
	const std::string& theKey,
	const std::string& theValue)
{
	// Open source file
	const std::wstring& aFilePathW = widen(theFilePath);
	std::ifstream aFile(aFilePathW.c_str(), std::ios::binary);
	if( !aFile.is_open() )
	{
		const std::string anError =
			strFormat("Could not open file %s", theFilePath.c_str());
		if( sLoadedProfileName.empty() )
			Dialogs::showError(anError);
		else
			logError(anError.c_str());
		return;
	}

	// Create temp output file
	const std::wstring& aTmpPath = getTempFilePathFor(aFilePathW);
	std::ofstream aTmpFile(
		aTmpPath.c_str(),
		std::ios::binary | std::ios::trunc);
	if( !aTmpFile.is_open() )
	{
		const std::string anError =
			strFormat("Could not create temp file %ls", aTmpPath.c_str());
		if( sLoadedProfileName.empty() )
			Dialogs::showError(anError);
		else
			logError(anError.c_str());
		aFile.close();
		return;
	}

	// Prepare buffer
	// +1 on size is to accommodate an extra newline character when
	// reach end of file for simpler parsing code
	char aBuffer[kINIFileBufferSize+1];
	std::streamsize aBufferSize = kINIFileBufferSize;
	std::string aCheckStr;
	const std::string& aCmpSection = condense(theSection);
	const std::string& aCmpKey = condense(theKey);

	enum
	{
		eSKVState_FindSection,
		eSKVState_CheckSection,
		eSKVState_SkipSectionLine,
		eSKVState_FindKey,
		eSKVState_CheckKey,
		eSKVState_FinishKeyLine,
		eSKVState_SkipKeyLine,
		eSKVState_ValueLine,
		eSKVState_Finished,
	} aState = eSKVState_FindSection;

	// Parse the INI file to find start and end of segment to replace
	const std::fstream::pos_type kInvalidFilePos = -1;
	std::fstream::pos_type aReplaceStartPos = kInvalidFilePos;
	std::fstream::pos_type aReplaceEndPos = kInvalidFilePos;
	std::fstream::pos_type anEndOfValidSection = kInvalidFilePos;
	std::fstream::pos_type aCurrFilePos = aFile.tellg();
	std::fstream::pos_type aValidFileCharsEnd = kInvalidFilePos;

	if( theSection.empty() )
	{
		aState = eSKVState_FindKey;
		anEndOfValidSection = 0;
	}

	while(aFile.good() && aState != eSKVState_Finished)
	{
		// Read next chunk from file
		aFile.read(aBuffer, aBufferSize);
		if( aFile.eof() || aFile.gcount() < aBufferSize )
		{// Put eol at end of file in case there wasn't one already
			aBufferSize = aFile.gcount() + 1;
			aBuffer[aBufferSize-1] = '\n';
			DBG_ASSERT(aBufferSize <= ARRAYSIZE(aBuffer));
		}
		else if( aFile.bad() )
		{
			const std::string anError =
				strFormat("Unknown error reading %s", theFilePath.c_str());
			if( sLoadedProfileName.empty() )
				Dialogs::showError(anError);
			else
				logError(anError.c_str());
			aFile.close();
			return;
		}

		for(int i = 0; i < aBufferSize && aState != eSKVState_Finished; ++i)
		{// Step through buffer character-by-character
			const char c = aBuffer[i];
			switch(aState)
			{
			case eSKVState_FindSection:
				// Look for a section
				if( c == '[' )
				{
					aState = eSKVState_CheckSection;
					aCheckStr.clear();
				}
				else if( u8(c) > ' ' )
				{
					aState = eSKVState_SkipSectionLine;
				}
				break;

			case eSKVState_CheckSection:
				// Look for endline after ']' to end section
				switch(c)
				{
				case '\r': case '\n': case '\0':
					aState = eSKVState_FindSection;
					aCheckStr = condense(aCheckStr);
					if( aCheckStr.size() > 1 &&
						aCheckStr[aCheckStr.size()-1] == ']' )
					{
						aCheckStr.resize(aCheckStr.size()-1);
						if( aCheckStr == aCmpSection )
						{
							aState = eSKVState_FindKey;
							anEndOfValidSection = aCurrFilePos;
						}
						else if( aCmpSection.empty() )
						{
							aState = eSKVState_Finished;
						}
					}
					break;
				default:
					aCheckStr.push_back(c);
					break;
				}
				break;

			case eSKVState_SkipSectionLine:
				// Look for end of line than resume section search
				if( c == '\r' || c == '\n' || c == '\0' )
					aState = eSKVState_FindSection;
				break;

			case eSKVState_FindKey:
				// Look for start of a key
				if( c == '[' )
				{
					aState = eSKVState_CheckSection;
					aCheckStr.clear();
				}
				else if( c == '#' || c == ';' )
				{
					aState = eSKVState_SkipKeyLine;
				}
				else if( u8(c) > ' ' )
				{
					aState = eSKVState_CheckKey;
					aCheckStr.clear();
					aCheckStr.push_back(c);
				}
				break;

			case eSKVState_CheckKey:
				// Look for '=' to end key
				if( c == '=' )
				{// End of the key - check if this is the one being looked for
					if( condense(aCheckStr) == aCmpKey )
					{// Found starting position to replace with new characters!
						aReplaceStartPos = aCurrFilePos;
						aReplaceStartPos += std::fstream::off_type(1);
						aState = eSKVState_ValueLine;
					}
					else
					{// Not the right key, but could be last key of section
						aState = eSKVState_FinishKeyLine;
					}
				}
				else if( c == '\r' || c == '\n' || c == '\0' )
				{// Abort - invalid key
					aState = eSKVState_FindKey;
				}
				else
				{
					aCheckStr.push_back(c);
				}
				break;

			case eSKVState_FinishKeyLine:
				// Continue to end of line then resume key search
				if( c == '\r' || c == '\n' || c == '\0' )
				{
					aState = eSKVState_FindKey;
					anEndOfValidSection = aCurrFilePos;
				}
				break;

			case eSKVState_SkipKeyLine:
				// Look for end of line then resume key search
				if( c == '\r' || c == '\n' || c == '\0' )
					aState = eSKVState_FindKey;
				break;

			case eSKVState_ValueLine:
				// Look for eol to end section to replace
				if( c == '\r' || c == '\n' || c == '\0' )
				{
					aReplaceEndPos = aCurrFilePos;
					aState = eSKVState_Finished;
				}
				break;
			}
			aCurrFilePos += std::fstream::off_type(1);
		}
	}

	// Find the last non-whitespace character of the file overall
	aFile.clear();
	aFile.seekg(0, std::ios::end);
	while( aFile.tellg() != std::fstream::pos_type(0) )
	{
		aFile.seekg(-1, std::ios::cur);
		if( u8(aFile.peek()) > ' ' )
			break;
	}
	if( aFile.tellg() != std::fstream::pos_type(0) ||
		(aFile.peek() != EOF && u8(aFile.peek()) > ' ') )
	{
		aFile.seekg(1, std::ios::cur);
		aValidFileCharsEnd = aFile.tellg();
	}
	aFile.clear();

	// Decide what to write and where exactly from info gathered above
	std::string aWriteString;
	if( aReplaceStartPos != kInvalidFilePos )
	{
		// Found the existing key, just write new value
		DBG_ASSERT(aReplaceEndPos != kInvalidFilePos);
		aWriteString = std::string(" ") + trim(theValue);
	}
	else if( anEndOfValidSection == std::fstream::pos_type(0) )
	{
		// Write new entry right at start of the file
		DBG_ASSERT(theSection.empty());
		aReplaceStartPos = aReplaceEndPos = 0;
		aWriteString = trim(theKey) + " = " + trim(theValue);
		if( aValidFileCharsEnd != kInvalidFilePos )
			aWriteString += kEndOfLine + kEndOfLine;
		
	}
	else if( anEndOfValidSection != kInvalidFilePos )
	{
		// Found section, write key and value
		aReplaceStartPos = aReplaceEndPos = anEndOfValidSection;
		aWriteString = kEndOfLine + trim(theKey) + " = " + trim(theValue);
	}
	else
	{
		// Found nothing - write section, key, and value
		aReplaceStartPos = aValidFileCharsEnd;
		aFile.seekg(0, std::ios::end);
		aReplaceEndPos = kInvalidFilePos;
		if( aReplaceStartPos != kInvalidFilePos )
			aWriteString = kEndOfLine + kEndOfLine;
		aWriteString += "[" + trim(theSection) + "]" + kEndOfLine;
		aWriteString += trim(theKey) + " = " + trim(theValue);
	}

	// Write aFile 0->aReplaceStartPos to temp file
	if( aReplaceStartPos != kInvalidFilePos &&
		aReplaceStartPos > std::fstream::pos_type(0) )
	{
		aFile.seekg(0, std::ios::beg);
		aCurrFilePos = aFile.tellg();
		while(aCurrFilePos < aReplaceStartPos && aFile.good())
		{
			std::streamsize aBytesToRead = aReplaceStartPos - aCurrFilePos;
			aBytesToRead = MIN(aBytesToRead, kINIFileBufferSize);
			aFile.read(aBuffer, aBytesToRead);
			aTmpFile.write(aBuffer, aFile.gcount());
			aCurrFilePos += aFile.gcount();
		}
	}

	// Write new data
	aTmpFile << aWriteString;

	// Write aReplaceEndPos->aValidFileCharsEnd to temp file
	if( aReplaceEndPos != kInvalidFilePos &&
		aValidFileCharsEnd != kInvalidFilePos &&
		aValidFileCharsEnd > aReplaceEndPos )
	{
		aFile.seekg(aReplaceEndPos, std::ios::beg);
		aCurrFilePos = aFile.tellg();
		while(aCurrFilePos < aValidFileCharsEnd && aFile.good())
		{
			std::streamsize aBytesToRead = aValidFileCharsEnd - aCurrFilePos;
			aBytesToRead = MIN(aBytesToRead, kINIFileBufferSize);
			aFile.read(aBuffer, aBytesToRead);
			aTmpFile.write(aBuffer, aFile.gcount());
			aCurrFilePos += aFile.gcount();
		}
	}

	// Write a single blank line at end of file
	aTmpFile.write(kEndOfLine.c_str(), kEndOfLine.size());

	// Close both files
	aFile.close();
	aTmpFile.close();

	// Replace original file with temp file (temp file is moved/consumed)
	if( !ReplaceFile(aFilePathW.c_str(), aTmpPath.c_str(),
			NULL, REPLACEFILE_IGNORE_MERGE_ERRORS, NULL, NULL) )
	{
		const std::string anError =
			strFormat("Failed to modify file %s!", theFilePath.c_str());
		if( sLoadedProfileName.empty() )
			Dialogs::showError(anError);
		else
			logError(anError.c_str());
	}
}


static void initSectionMap()
{
	DBG_ASSERT(sSectionsMap.empty());
	confirmSafeToWriteToMap();
	// Make sure "variables" section is always section 0
	sSectionsMap.setValue(kVariablesSectionName, PropertyMap());
	sVarPropDepList.clear();
	// Add built-in system variables to variables section
	PropertyMap& aVarMap = sSectionsMap.vals()[kVarsSectionIdx];
	Property aProp;
	aProp.str = "1.0"; aVarMap.setValue(kUIScaleVarName, aProp);
	aProp.str = "1920"; aVarMap.setValue(kWidthVarName, aProp);
	aProp.str = "1080"; aVarMap.setValue(kHeightVarName, aProp);
	DBG_ASSERT(sSectionsMap.keys()[kVarsSectionIdx] == kVariablesSectionName);
	DBG_ASSERT(aVarMap.keys()[kUIScaleVarID] == kUIScaleVarName);
	DBG_ASSERT(aVarMap.keys()[kWidthVarID] == kWidthVarName);
	DBG_ASSERT(aVarMap.keys()[kHeightVarID] == kHeightVarName);
}


static void generateResourceFile(const ResourceFile& theResFile)
{
	const std::string& aFilePath =
		profileNameToFilePath(theResFile.fileName);

	if( !writeResourceToFile(theResFile.resID,
			L"TEXT", widen(aFilePath).c_str()) )
	{
		logFatalError("Unable to write Profile data to file %s\n",
			aFilePath.c_str());
		return;
	}

	if( theResFile.version )
	{
		setPropertyInINI(aFilePath,
			"", kAutoGenVersionKey,
			toString(theResFile.version));
	}
}


static void getProfileListCallback(
	const std::string& theSection,
	const std::string& theName,
	const std::string& theValue,
	void*)
{
	if( theValue.empty() )
		return;
	DBG_ASSERT(theSection.empty());
	const std::string& aProfileNameKey = condense(theName);
	const std::string& aProfileKeyPrefix = condense(kProfileKeyPrefix);
	if( aProfileNameKey.compare(0,
			aProfileKeyPrefix.length(), aProfileKeyPrefix) == 0 )
	{// Profile name entry
		const int aProfileNum =
			stringToInt(aProfileNameKey.substr(aProfileKeyPrefix.length()));
		if( aProfileNum > 0 && !theValue.empty() )
		{
			const ProfileFile& aFile = profileNameToFile(theValue);
			if( fileExists(aFile) )
			{
				if( aProfileNum >= intSize(sProfiles.size()) )
					sProfiles.resize(aProfileNum + 1);
				sProfiles[aProfileNum].name = aFile.name;
				sProfiles[aProfileNum].fileIDs.push_back(
					getOrAddKnownFileID(aFile));
			}
			else
			{
				Dialogs::showError(strFormat(
					"Could not find/open profile '%s' (%s) listed in %s. "
					"Edit the core .ini text file to remove this profile.", 
					theValue.c_str(),
					aFile.path.c_str(),
					kCoreProfileName));
			}
		}
	}
	else if( aProfileNameKey == condense(kAutoLoadProfileKey) )
	{// Auto-load profile entry
		sAutoLoadProfileID = stringToInt(theValue);
	}
}


static void addParentCallback(
	const std::string& theSection,
	const std::string& theName,
	const std::string& theValue,
	void* theLoadList)
{
	DBG_ASSERT(theSection.empty());
	if( !theLoadList || theValue.empty() )
		return;

	std::vector<int>* aLoadPriorityList = (std::vector<int>*)(theLoadList);

	if( condense(theName) == "PARENTPROFILE" || condense(theName) == "PARENT" )
	{
		const std::string& aProfileName = extractProfileName(theValue);
		ProfileFile aFile = profileNameToFile(aProfileName);
		if( !fileExists(aFile) )
		{// File not found - but maybe referencing a resource base file?
			const std::string& aCmpName = condense(aProfileName);
			for(int i = 0; i < ARRAYSIZE(kResTemplateBase); ++i)
			{
				if( condense(kResTemplateBase[i].fileName) == aCmpName )
				{
					generateResourceFile(kResTemplateBase[i]);
					aFile = profileNameToFile(aProfileName);
					sNewBaseProfileIdx = getOrAddKnownFileID(aFile);
					break;
				}
			}
		}
		if( !fileExists(aFile) )
		{// File still not found - maybe referencing a resource default file?
			const std::string& aCmpName = condense(aProfileName);
			for(int i = 0; i < ARRAYSIZE(kResTemplateDefault); ++i)
			{
				if( condense(kResTemplateDefault[i].fileName) == aCmpName )
				{
					generateResourceFile(kResTemplateDefault[i]);
					aFile = profileNameToFile(aProfileName);
					sNewBaseProfileIdx = getOrAddKnownFileID(aFile);
					break;
				}
			}
		}
		if( fileExists(aFile) )
		{
			const int aParentFileIdx = getOrAddKnownFileID(aFile);
			// Don't add Core as parent if specified (it's added automatically)
			if( aParentFileIdx == 0 )
				return;
			// Don't add entries already added (or can get infinite loop)!
			if( std::find(aLoadPriorityList->begin(), aLoadPriorityList->end(),
					aParentFileIdx) != aLoadPriorityList->end() )
				return;
			aLoadPriorityList->push_back(aParentFileIdx);
		}
		else
		{
			Dialogs::showError(strFormat(
				"Could not find/open '%s' Profile's parent: '%s' (%s)",
				sKnownFiles[*(aLoadPriorityList->begin())].name.c_str(),
				theValue.c_str(), aFile.path.c_str()));
		}
	}
}


static void generateProfileLoadPriorityList(int theProfileID)
{
	DBG_ASSERT(size_t(theProfileID) < sProfiles.size());
	std::vector<int>& aList = sProfiles[theProfileID].fileIDs;
	if( aList.empty() )
		return;

	// Should only have the main file as first priority at this point
	DBG_ASSERT(aList.size() == 1);
	DBG_ASSERT(size_t(aList[0]) < sKnownFiles.size());

	// Parse main profile and add parent, parent of parent, etc.
	// NOTE: aList.size() can grow during this, so must be checked each loop
	for(size_t i = 0; i < aList.size(); ++i)
	{
		parseINI(
			addParentCallback,
			sKnownFiles[aList[i]].path,
			eParseMode_Header,
			&aList);
	}

	// Finally add core .ini as lowest-priority settings
	aList.push_back(0);
}


static void parseProfilesCanLoad()
{
	sKnownFiles.clear();
	sProfiles.resize(1); // includes a dummy 0th entry
	sAutoLoadProfileID = 0;

	// Initially core .ini is only profile file known, with others added
	// via parsing core (and other profiles when checking for parents)
	ProfileFile aCoreFile = profileNameToFile(kCoreProfileName);
	if( !fileExists(aCoreFile) )
	{
		logFatalError("Could not find %s (%s)",
			kCoreProfileName, aCoreFile.path.c_str());
		return;
	}

	// Make sure Core is first known file (index 0)
	getOrAddKnownFileID(aCoreFile);

	// Get list of load-able profiles and auto-load profile from core
	parseINI(
		getProfileListCallback,
		aCoreFile.path,
		eParseMode_Header);

	// Fill in the remaining files needed for each found profile
	for(int i = 0, end = intSize(sProfiles.size()); i < end; ++i)
		generateProfileLoadPriorityList(i);
}


static void generateKnownIssuesRTF(std::string theIssuesList)
{
	sNeedShowKnownIssues = false;
	sKnownIssuesRTF.clear();
	StringToValueMap<bool> anIssuesMap;
	while(!theIssuesList.empty())
		anIssuesMap.setValue(breakOffNextItem(theIssuesList), true);

	HRSRC hRes = FindResource(null,
		MAKEINTRESOURCE(IDR_TEXT_KNOWN_ISSUES), L"TEXT");
	DBG_ASSERT(hRes);
	HGLOBAL hData = LoadResource(null, hRes);
	DBG_ASSERT(hData);
	const char* aResStr = (const char*)LockResource(hData);
	sKnownIssuesRTF = aResStr;
	FreeResource(hRes);

	// Find which issues to display and filter out the rest
	std::pair<std::string::size_type, std::string::size_type> aTagCoords;
	aTagCoords = findStringTag(sKnownIssuesRTF);
	std::string anIssueName;
	std::string aTagContents;
	while(aTagCoords.first != std::string::npos)
	{
		aTagContents = sKnownIssuesRTF.substr(
			aTagCoords.first+1, aTagCoords.second-2);
		anIssueName = breakOffItemBeforeChar(aTagContents);
		if( anIssueName == "NONE" )
		{// Show contents only if have no issues so far
			// This should be the last tag in the .rtf resource file!
			if( sNeedShowKnownIssues )
				aTagContents.clear();
		}
		else if( anIssuesMap.contains(anIssueName) )
		{// Note that have found at least one known issue
			sNeedShowKnownIssues = true;
		}
		else
		{// Not a known issue for this title - strip entirely
			aTagContents.clear();
		}
		sKnownIssuesRTF.replace(
			aTagCoords.first,
			aTagCoords.second,
			aTagContents);
		aTagCoords = findStringTag(sKnownIssuesRTF);
	}
}


static void readBaseGameSettingsCallback(
	const std::string& theSection,
	const std::string& theName,
	const std::string& theValue,
	void* theAppInfo)
{
	if( !theAppInfo || theValue.empty() )
		return;

	BaseGameSettings* theSettings = (BaseGameSettings*)(theAppInfo);
	if( condense(theSection) == condense(kBaseGameSettingsSection) )
	{
		if( condense(theName) == condense(kAutoLaunchAppKey) )
			theSettings->autoLaunch.path = theValue;
		if( condense(theName) == condense(kAutoLaunchAppParamsKey) )
			theSettings->autoLaunch.params = theValue;
		if( condense(theName) == condense(kKnownIssuesKey) )
			theSettings->knownIssuesList = theValue;
	}
}


static BaseGameSettings getBaseGameSettings(const ProfileFile& theFile)
{
	BaseGameSettings result;

	parseINI(
		readBaseGameSettingsCallback,
		theFile.path,
		eParseMode_Sections,
		&result);

	return result;
}


static void writeBaseGameSettingsChanges(
	ProfileFile& theFile,
	const BaseGameSettings& theDefaultSettings,
	const BaseGameSettings& theCustomSettings)
{
	if( !theCustomSettings.autoLaunch.path.empty() ||
		!theDefaultSettings.autoLaunch.path.empty() )
	{
		setPropertyInINI(
			theFile.path,
			kBaseGameSettingsSection, kAutoLaunchAppKey,
			theCustomSettings.autoLaunch.path);
	}
	if( !theCustomSettings.autoLaunch.params.empty() ||
		!theDefaultSettings.autoLaunch.params.empty() )
	{
		setPropertyInINI(
			theFile.path,
			kBaseGameSettingsSection, kAutoLaunchAppParamsKey,
			theCustomSettings.autoLaunch.params);
	}
}


static void setAutoLoadProfile(int theProfileID)
{
	if( theProfileID == sAutoLoadProfileID )
		return;

	DBG_ASSERT(!sKnownFiles.empty());
	sAutoLoadProfileID = theProfileID;

	setPropertyInINI(
		sKnownFiles[0].path,
		"", kAutoLoadProfileKey,
		theProfileID ? toString(theProfileID) : std::string());
}


#ifndef _DEBUG
static void readVersionCallback(
	const std::string& /*theSection*/,
	const std::string& theName,
	const std::string& theValue,
	void* theVersion)
{
	if( !theVersion || theValue.empty() )
		return;

	int* aVersion = (int*)(theVersion);
	if( condense(theName) == condense(kAutoGenVersionKey) )
		*aVersion = stringToInt(theValue);
}
#endif


static void checkForOutdatedFileVersion(ProfileFile& theFile)
{
	const ResourceFile* theMatchingResource = NULL;
	bool matchingResourceIsCore = false;
	bool matchingResourceIsBase = false;
	if( theFile.name == kResTemplateCore.fileName )
	{
		theMatchingResource = &kResTemplateCore;
		matchingResourceIsCore = true;
	}
	if( !theMatchingResource )
	{
		for(int i = 0; i < ARRAYSIZE(kResTemplateBase); ++i)
		{
			if( theFile.name == kResTemplateBase[i].fileName )
			{
				theMatchingResource = &kResTemplateBase[i];
				matchingResourceIsBase = true;
				break;
			}
		}
	}
	if( !theMatchingResource )
	{
		for(int i = 0; i < ARRAYSIZE(kResTemplateDefault); ++i)
		{
			if( theFile.name == kResTemplateDefault[i].fileName )
			{
				theMatchingResource = &kResTemplateDefault[i];
				break;
			}
		}
	}
	// Only replace custom files in Debug builds, and only for first loaded
	#ifdef _DEBUG
	if( !theMatchingResource && sLoadedProfileName.empty() )
	{
		for(int i = 0; i < ARRAYSIZE(kResTemplateCustom); ++i)
		{
			if( theFile.name == kResTemplateCustom[i].fileName )
			{
				theMatchingResource = &kResTemplateCustom[i];
				break;
			}
		}
	}
	#endif
	if( !theMatchingResource )
		return;

	// In Debug builds, always (silently) regenerate all generated files
	// every time so always reflect any changes made to resource versions.
	EResult aResult = eResult_Yes;
	#ifndef _DEBUG
	// Check for version number stored in the file
	int aFileVersion = 0;
	parseINI(
		readVersionCallback,
		theFile.path,
		eParseMode_Header,
		&aFileVersion);

	// If version number not specified (or set to 0), ignore it
	if( !aFileVersion )
		return;
	// If file version number >= expected, no change needed
	if( aFileVersion >= theMatchingResource->version )
		return;
	// File is outdated - prompt to replace it!
	aResult = Dialogs::yesNoPrompt(strFormat(
			"File '%s' was auto-generated by a previous version of this app."
			"Would you like to replace it with an updated version?\n\n"
			"Any changes made to it since it was generated%swill be lost!",
			getFileName(theFile.path).c_str(),
			matchingResourceIsCore ? " (besides the profile list) " :
			matchingResourceIsBase ? " (besides auto-launch app path) " : " "),
			"Update outdated generated file", true);
	#endif
	if( aResult == eResult_Yes )
	{// Update the generated file to new version
		BaseGameSettings aCustomSettings;
		if( matchingResourceIsBase )
			aCustomSettings = getBaseGameSettings(theFile);
		generateResourceFile(*theMatchingResource);
		if( matchingResourceIsCore )
		{// Restore known profile list & auto-load setting to regenerated Core
			setPropertyInINI(
				sKnownFiles[0].path,
				"", kAutoLoadProfileKey,
				sAutoLoadProfileID > 0
					? toString(sAutoLoadProfileID)
					: std::string());
			for(int i = 1, end = intSize(sProfiles.size()); i < end; ++i)
			{
				setPropertyInINI(
					theFile.path, "",
					std::string(kProfileKeyPrefix) + toString(i),
					sProfiles[i].name);
			}
		}
		else if( matchingResourceIsBase )
		{// Restore base game setting changes to regenerated Base file
			const BaseGameSettings& aDefaultSettings =
				getBaseGameSettings(theFile);

			writeBaseGameSettingsChanges(
				theFile, aDefaultSettings, aCustomSettings);

			#ifndef _DEBUG
			// Generate known issues and, if there are any, display them now,
			// in case they have changed since previous version of app
			generateKnownIssuesRTF(aDefaultSettings.knownIssuesList);
			if( sNeedShowKnownIssues )
			{
				Dialogs::showKnownIssues();
				sNeedShowKnownIssues = false;
			}
			#endif
		}
	}
	else if( aResult == eResult_No )
	{
		// Update the file's version number so won't ask again
		setPropertyInINI(theFile.path,
			"", kAutoGenVersionKey,
			toString(theMatchingResource->version));
	}
	// else if( aResult == eResult_Cancel )
	// Ignore this time since are in-game already - ask again next time!
}


static bool userEditProfile(int theProfileID, bool firstProfile)
{
	// Generate list of files to possibly edit
	DBG_ASSERT(size_t(theProfileID) < sProfiles.size());
	const std::vector<int>& aList = sProfiles[theProfileID].fileIDs;
	DBG_ASSERT(!aList.empty());

	std::vector<std::string> aFileList;
	for(std::vector<int>::const_reverse_iterator itr = aList.rbegin();
		itr != aList.rend(); ++itr)
	{
		DBG_ASSERT(size_t(*itr) < sKnownFiles.size());
		checkForOutdatedFileVersion(sKnownFiles[*itr]);
		aFileList.push_back(sKnownFiles[*itr].path);
	}

	// Note file modification times to check if any actual changes are made
	static std::vector<FILETIME> sLastFileModTime;
	sLastFileModTime.resize(aList.size());
	for(size_t i = 0; i < aFileList.size(); ++i)
		sLastFileModTime[i] = getFileLastModTime(sKnownFiles[aList[i]].path);

	Dialogs::profileEdit(aFileList, firstProfile);

	// Test if any actual changes were made to any of the profile's files
	for(size_t i = 0; i < aFileList.size(); ++i)
	{
		const ProfileFile& aFile = sKnownFiles[aList[i]];
		if( !fileExists(aFile) )
			return true;
		const FILETIME& aNewFileTime = getFileLastModTime(aFile.path);
		if( CompareFileTime(&sLastFileModTime[i], &aNewFileTime) != 0 )
			return true;
	}

	return false;
}


static void logPropVarDependency(VarPropDependency theDep, bool init)
{
	if( init )
	{
		// Just push on to the list and it will be sorted in later
		sVarPropDepList.push_back(theDep);
		return;
	}

	std::vector<VarPropDependency>::iterator itr = std::lower_bound(
		sVarPropDepList.begin(), sVarPropDepList.end(), theDep);
	if( itr == sVarPropDepList.end() || !(*itr == theDep) )
		sVarPropDepList.insert(itr, theDep);
}


static std::string varTagToString(
	const std::string& theVarContents,
	const std::string& theTagStr,
	const size_t theFirstOperatorPos,
	VarPropDependency* theVarDep = null,
	bool init = false)
{
	std::string result = theVarContents;
	// Replace quoted string with un-trimmed contents
	if( result.size() >= 2 &&
		((result[0] == '"' && result[result.size()-1] == '"') ||
		 (result[0] == '\'' && result[result.size()-1] == '\'')) )
	{
		result = result.substr(1, result.size()-2);
	}

	DBG_ASSERT(theFirstOperatorPos < theTagStr.size());
	size_t aPos = theFirstOperatorPos;
	// Figure out what operator we're dealing with (some use 2 chars)
	u8 anOpC = theTagStr[aPos++];
	const char* aNextDel = "?}";
	switch(anOpC)
	{
	case '}':
		return result;
	case '?':
		aNextDel = ":}";
		break;
	case '~':
		anOpC = '!';
		// fall through
	case '!':
		// Ignore extra '=' for '!=' or '~='
		if( theTagStr[aPos] == '=' )
			++aPos;
		break;
	case '<':
		if( theTagStr[aPos] == '>' )
		{// Treat <> as alternate form of '!'
			anOpC = '!';
			++aPos;
		}
		else if( theTagStr[aPos] == '=' )
		{// Use '[' to mean less-than-or-equal (internally only)
			anOpC = '[';
			++aPos;
		}
		break;
	case '>':
		if( theTagStr[aPos] == '=' )
		{// Use ']' to mean less-than-or-equal (internally only)
			anOpC = ']';
			++aPos;
		}
		break;
	case '=':
		// Ignore extra '='
		if( theTagStr[aPos] == '=' )
			++aPos;
		break;
	case '+': case '-': case '*': case '/':
		aNextDel = "}+*/?!~<>="; // to warn of multi-operator use (except -)
		break;
	case '.':
		// Not really an operator, so find the actual operator next (if any)
		aNextDel = "}+-*/?!~<>=.";
		break;
	default:
		DBG_ASSERT(false && "Unhandled operator character");
	}

	// Get first parameter for operator
	const std::string& aParam = fetchNextItem(theTagStr, aPos, aNextDel);

	// Check for special .anchor, .offset, .x/xs, and .y/ys for coord vars
	if( anOpC == '.' )
	{
		enum {
			eMemberType_Unknown,
			eMemberType_X,
			eMemberType_Y,
			eMemberType_XScaled,
			eMemberType_YScaled,
			eMemberType_Offset,
			eMemberType_Anchor,
		} aMemberType = eMemberType_Unknown;
		if( condense(aParam) == "X" )
			aMemberType = eMemberType_X;
		else if( condense(aParam) == "Y" )
			aMemberType = eMemberType_Y;
		if( condense(aParam) == "XS" )
			aMemberType = eMemberType_XScaled;
		else if( condense(aParam) == "YS" )
			aMemberType = eMemberType_YScaled;
		else if( condense(aParam) == "OFFSET" )
			aMemberType = eMemberType_Offset;
		else if( condense(aParam) == "ANCHOR" )
			aMemberType = eMemberType_Anchor;

		if( aMemberType == eMemberType_Unknown )
		{
			logError("Uknown operator '%c%s' in '%s'!",
				anOpC, aParam.c_str(), theTagStr.c_str());
			return varTagToString(result, theTagStr, aPos);
		}
		size_t aCoordStrPos = 0;
		const Hotspot::Coord& aCoord = stringToCoord(result, aCoordStrPos);
		if( aCoordStrPos != result.size() )
		{
			logError("Expected an anchor + offset coordinate string "
				"instead of '%s' for operator '%c%s' in '%s'!",
				result.c_str(), anOpC, aParam.c_str(), theTagStr.c_str());
			return varTagToString(result, theTagStr, aPos);
		}
		switch(aMemberType)
		{
		case eMemberType_X:
			{
				const u32 aMaxVal = stringToU32(sSectionsMap.vals()
					[kVarsSectionIdx].vals()[kWidthVarID].str);
				const int anAnchorVal = u16ToRangeVal(aCoord.anchor, aMaxVal);
				result = toString(clamp(
					anAnchorVal + aCoord.offset, 0, aMaxVal));
				if( theVarDep )
				{// Make sure this recalculates when needed
					theVarDep->varID = kWidthVarID;
					logPropVarDependency(*theVarDep, init);
				}
			}
			break;
		case eMemberType_Y:
			{
				const u32 aMaxVal = stringToU32(sSectionsMap.vals()
					[kVarsSectionIdx].vals()[kHeightVarID].str);
				const int anAnchorVal = u16ToRangeVal(aCoord.anchor, aMaxVal);
				result = toString(clamp(
					anAnchorVal + aCoord.offset, 0, aMaxVal));
				if( theVarDep )
				{// Make sure this recalculates when needed
					theVarDep->varID = kHeightVarID;
					logPropVarDependency(*theVarDep, init);
				}
			}
			break;
		case eMemberType_XScaled:
			{
				const u32 aMaxVal = stringToU32(sSectionsMap.vals()
					[kVarsSectionIdx].vals()[kWidthVarID].str);
				const int anAnchorVal = u16ToRangeVal(aCoord.anchor, aMaxVal);
				const double aScale = stringToDouble(sSectionsMap.vals()
					[kVarsSectionIdx].vals()[kUIScaleVarID].str);
				result = toString(clamp(
					anAnchorVal + int(aCoord.offset * aScale), 0, aMaxVal));
				if( theVarDep )
				{// Make sure this recalculates when needed
					theVarDep->varID = kWidthVarID;
					logPropVarDependency(*theVarDep, init);
					theVarDep->varID = kUIScaleVarID;
					logPropVarDependency(*theVarDep, init);
				}
			}
			break;
		case eMemberType_YScaled:
			{
				const u32 aMaxVal = stringToU32(sSectionsMap.vals()
					[kVarsSectionIdx].vals()[kHeightVarID].str);
				const int anAnchorVal = u16ToRangeVal(aCoord.anchor, aMaxVal);
				const double aScale = stringToDouble(sSectionsMap.vals()
					[kVarsSectionIdx].vals()[kUIScaleVarID].str);
				result = toString(clamp(
					anAnchorVal + int(aCoord.offset * aScale), 0, aMaxVal));
				if( theVarDep )
				{// Make sure this recalculates when needed
					theVarDep->varID = kHeightVarID;
					logPropVarDependency(*theVarDep, init);
					theVarDep->varID = kUIScaleVarID;
					logPropVarDependency(*theVarDep, init);
				}
			}
			break;
		case eMemberType_Offset:
			result = toString(aCoord.offset);
			break;
		case eMemberType_Anchor:
			result = toString(aCoord.anchor / double(0x10000U));
			break;
		}
		return varTagToString(result, theTagStr, aPos);
	}

	// Check for valid values (i.e. numbers) for some operators
	double aVarNum = 0, aParamNum = 0;
	if( anOpC != '?' )
	{
		aVarNum = stringToDouble(result, true);
		if( _isnan(aVarNum) && anOpC != '!' && anOpC != '=' )
		{
			if( anOpC == '+' || anOpC == '-' )
			{// Check if a hotspot coord format and can just +/- the offset
				size_t aCoordStrPos = 0;
				stringToCoord(result, aCoordStrPos);
				if( aCoordStrPos == result.size() )
				{// Valid hotspot coord format! Just append operator & param
					result += theTagStr.substr(theFirstOperatorPos, 
						theTagStr.find('}') - theFirstOperatorPos);
					return result;
				}
			}
			logError("Expected a number instead of '%s' for "
				"operator '%c' in '%s'!",
				result.c_str(), anOpC, theTagStr.c_str());
			aVarNum = stringToBool(aParam) ? 1.0 : 0;
		}
		aParamNum = stringToDouble(aParam, true);
		if( _isnan(aParamNum) && anOpC != '!' && anOpC != '=' )
		{
			logError("Expected a number instead of '%s' for "
				"operator '%c' in '%s'. "
				"Note only one operator is allowed per ${} block!",
				aParam.c_str(), anOpC, theTagStr.c_str());
			aParamNum =
				(anOpC == '+' || anOpC == '-') ? 0 :
				(anOpC == '*' || anOpC == '/') ? 1.0 :
				stringToBool(aParam) ? 1.0 : 0;
		}
	}

	// Have all we need for arithmetic operators now
	if( anOpC == '+' || anOpC == '-' || anOpC == '*' || anOpC == '/' )
	{
		if( theTagStr[aPos] != '}' )
		{
			logError("Unexpected %c found in '%s'. "
				"Only one operator is allowed per ${} block! "
				"Use nested ${} blocks for more options.",
				theTagStr[aPos], theTagStr.c_str());
		}
		switch(anOpC)
		{
		case '+': aVarNum += aParamNum; break;
		case '-': aVarNum -= aParamNum; break;
		case '*': aVarNum *= aParamNum; break;
		case '/':
			if( aParamNum == 0 )
			{
				logError("Division by 0 detected in '%s'!",
					theTagStr.c_str());
				aParamNum = 1.0;
			}
			aVarNum /= aParamNum;
			break;
		}
		result = toString(aVarNum);
		return result;
	}

	// Math done, should only be comparison or ? operator now
	bool isTrue = false;
	switch(anOpC)
	{
	case '<':
		isTrue = aVarNum < aParamNum;
		break;
	case '[':
		isTrue = aVarNum <= aParamNum;
		break;
	case '>':
		isTrue = aVarNum > aParamNum;
		break;
	case ']':
		isTrue = aVarNum >= aParamNum;
		break;
	case '=': case '!':
		{
			if( !_isnan(aVarNum) && !_isnan(aParamNum) )
				isTrue = aVarNum == aParamNum;
			else
				isTrue = condense(result) == condense(aParam);
			if( anOpC == '!' )
				isTrue = !isTrue;
		}
		break;
	case '?':
		isTrue = stringToBool(result);
		break;
	default:
		DBG_ASSERT(false && "Unhandled conditional operator");
		break;
	}

	// What to do with compare result depends on second operator
	const char anOpC2 = theTagStr[aPos++];
	if( anOpC2 == '}' )
	{
		if( anOpC == '?' )
		{// ${Var ? resultIfTrue}
			result = isTrue ? aParam : "";
			return result;
		}
		// ${Var !<=> value} (debugging? inner part of a more complex block?)
		result = isTrue ? "true" : "";
		return result;
	}

	if( anOpC2 == ':' )
	{// ${Var ? resultIfTrue : resultIfFalse}
		DBG_ASSERT(anOpC == '?');
		if( isTrue )
		{
			result = aParam;
			return result;
		}
		result = fetchNextItem(theTagStr, aPos, "}");
		return result;
	}

	// ${Var !<=> value ? ...} if got this far
	DBG_ASSERT(anOpC2 == '?');

	// Get result for true, or to advance aPos to : for false condition result
	const std::string& aTrueResult = fetchNextItem(theTagStr, aPos, ":}");
	if( isTrue )
		result = aTrueResult;
	else if( theTagStr[aPos++] == ':' )
		result = fetchNextItem(theTagStr, aPos, "}");
	else
		result = "";

	// result is now aTrueResult if condition was true, the section after :
	// if condition was false, or empty if there was no ':' section
	// (${Var !<=> value ? result} format) and condition was false
	return result;
}


static void expandPropertyVars(int theSectionID, int thePropID, bool init)
{
	PropertyMap& theSection = sSectionsMap.vals()[theSectionID];
	Property& theProp = theSection.vals()[thePropID];
	if( !theProp.str.empty() || theProp.pattern.empty() )
		return;

	std::pair<std::string::size_type, std::string::size_type> aTagCoords =
		findStringTag(theProp.pattern, 0, "${", '}');

	if( aTagCoords.first == std::string::npos )
	{// No variables referenced - set .str and clear .pattern via swap
		swap(theProp.str, theProp.pattern);
		return;
	}

	VarPropDependency aDep;
	aDep.sectID = theSectionID;
	aDep.propID = thePropID;
	PropertyMap& theVarsMap = sSectionsMap.vals()[kVarsSectionIdx];
	DBG_ASSERT(sSectionsMap.keys()[kVarsSectionIdx] == kVariablesSectionName);

	theProp.str = "\b"; // to detect circular reference from recursion
	std::string aStr = theProp.pattern;
	do {
		// Extract variable name from tag
		size_t aVarOpPos = aTagCoords.first + 2;
		const std::string& aVarName =
			fetchNextItem(aStr, aVarOpPos, "}+-*/?!~<>=.");

		DBG_ASSERT(aVarOpPos < aTagCoords.first + aTagCoords.second);
		std::string aRepStr;
		if( aVarName.empty() )
		{
			logError("Missing variable name in property "
				"[%s] / %s = %s!",
				sSectionsMap.keys()[theSectionID].c_str(),
				theSection.keys()[thePropID].c_str(),
				aStr.c_str());
		}
		else
		{
			const int aVarID = theVarsMap.findIndex(aVarName);
			if( aVarID >= theVarsMap.size() )
			{
				logError("Variable name '%s' not found in property "
					"[%s] / %s = %s!",
					aVarName.c_str(),
					sSectionsMap.keys()[theSectionID].c_str(),
					theSection.keys()[thePropID].c_str(),
					aStr.c_str());
			}
			else
			{
				Property& aVarProp = theVarsMap.vals()[aVarID];
				if( aVarProp.str == "\b" )
				{
					logError("Variable '%s' references self!",
						aVarName.c_str());
				}
				else
				{
					aDep.varID = aVarID;
					logPropVarDependency(aDep, init);
					if( aVarProp.str.empty() && !aVarProp.pattern.empty() )
						expandPropertyVars(kVarsSectionIdx, aVarID, init);

					aRepStr = varTagToString(
						aVarProp.str, aStr, aVarOpPos, &aDep, init);
				}
			}
		}
		aStr = aStr.replace(aTagCoords.first, aTagCoords.second, aRepStr);
		aTagCoords = findStringTag(aStr, 0, "${", '}');
	} while( aTagCoords.first != std::string::npos );

	theProp.str = aStr;
}


static void readProfileCallback(
	const std::string& theSection,
	const std::string& theName,
	const std::string& theValue,
	void*)
{
	int aSectionID = sSectionsMap.findOrAddIndex(theSection);
	PropertyMap& aSection = sSectionsMap.vals()[aSectionID];
	if( aSectionID == kVarsSectionIdx &&
		(((theName[0] < 'A' || theName[0] > 'Z') &&
		  (theName[0] < 'a' || theName[0] > 'z')) ||
		 (theName.find_first_of("{}+-*/?:!~<>=.") != std::string::npos)) )
	{
		logError(
			"Variable names must only contain alphanumeric characters "
			"and first character must be A-Z. '%s' is invalid.",
			theName.c_str());
		return;
	}
	Property& aProperty = aSection.findOrAdd(theName);
	aProperty.pattern = theValue;
	aProperty.str.clear();
}


static void propogatePropertyChange(int theSectionID, int thePropertyID)
{
	// Apply variable expansion to this property
	DBG_ASSERT(theSectionID >= 0 && theSectionID < sSectionsMap.size());
	PropertyMap& aSection = sSectionsMap.vals()[theSectionID];
	DBG_ASSERT(thePropertyID >= 0 && thePropertyID < aSection.size());
	Property& aProp = aSection.vals()[thePropertyID];
	if( !aProp.pattern.empty() )
	{
		aProp.str.clear();
		expandPropertyVars(theSectionID, thePropertyID, false);
	}

	if( theSectionID == kVarsSectionIdx )
	{// Property is a variable - update other properties that depend on it
		VarPropDependency aSearchVarDep;
		aSearchVarDep.varID = thePropertyID;
		for(std::vector<VarPropDependency>::const_iterator itr =
				std::lower_bound(
					sVarPropDepList.begin(),
					sVarPropDepList.end(),
					aSearchVarDep);
			itr != sVarPropDepList.end() && int(itr->varID) == thePropertyID;
			++itr)
		{
			propogatePropertyChange(itr->sectID, itr->propID);
		}
	}
	else
	{// Log property update in sChangedSectionsMap for other modules as well
		sChangedSectionsMap.findOrAdd(sSectionsMap.keys()[theSectionID])
			.setValue(aSection.keys()[thePropertyID], aProp);
	}
}


static void setPropertyAfterLoad(
	int theSectionID,
	int thePropertyID,
	const std::string& theValue,
	bool saveToFile)
{
	DBG_ASSERT(theSectionID >= 0 && theSectionID < sSectionsMap.size());

	PropertyMap& aSection = sSectionsMap.vals()[theSectionID];
	DBG_ASSERT(thePropertyID >= 0 && thePropertyID < aSection.size());
	Property& aProp = aSection.vals()[thePropertyID];

	const bool saveToMap = aProp.pattern.empty()
		? (aProp.str != theValue) : (aProp.pattern != theValue);
	saveToFile = saveToFile &&
		(aProp.file.empty() ? saveToMap : aProp.file != theValue);

	// If a temporary change, make a backup of original file string so that
	// if try re-applying the same value later but with saveToFile as true,
	// can detect need to save even though active map won't be updated.
	// Alternatively, if have a backup and below will set active value back
	// to matching what is saved to file, then no longer need the backup.
	if( saveToMap && !saveToFile )
	{
		if( aProp.file.empty() )
			swap(aProp.file, aProp.pattern.empty() ? aProp.str : aProp.pattern);
		else if( aProp.file == theValue )
			aProp.file.clear();
	}

	if( saveToMap )
	{
		// Set pattern string (at least temporarily - below may clear it)
		aProp.pattern = theValue;

		// Apply variable expansion (or just move from .pattern to .str),
		// if a variable property propogate it to other properties,
		// and log in changes map so outside modules are informed of change
		propogatePropertyChange(theSectionID, thePropertyID);
	}

	if( saveToFile )
	{// Log as change to save to file
		for(int i = 0, end = intSize(sUnsavedChangesList.size()); i < end; ++i)
		{
			if( sUnsavedChangesList[i].sectionID == theSectionID &&
				sUnsavedChangesList[i].propertyID == thePropertyID )
			{
				sUnsavedChangesList[i].value = theValue;
				return;
			}
		}

		sUnsavedChangesList.push_back(UnsavedProperty());
		sUnsavedChangesList.back().sectionID = theSectionID;
		sUnsavedChangesList.back().propertyID = thePropertyID;
		sUnsavedChangesList.back().value = theValue;

		// File data will now match active map data, so can set .file to be
		// the same as .pattern or .str, but .file.empty() means the same thing
		aProp.file.clear();
	}
}


int queryUserForProfileImpl(int& theLastCreatedProfileIdx)
{
	int result = 0;
	DBG_ASSERT(!sKnownFiles.empty());
	if( hadFatalError() )
		return result;

	// Create lists needed for dialog
	enum EType
	{
		eType_CopyFile,			// index into sKnownFiles
		eType_CopyResCustom,	// index into kResTemplateCustom
		eType_ParentResBase,	// index into kResTemplateBase
		eType_ParentResDefault,	// index into kResTemplateDefault
		eType_ParentFile,		// index into sKnownFiles
	};
	std::vector<std::string> aLoadableProfileNames;
	std::vector<int> aLoadableProfileIndexes;
	std::vector<std::string> aTemplateProfileNames;
	std::vector<int> aTemplateSourceFileIndexes;
	std::vector<EType> aTemplateProfileType;
	const std::string kCopyFilePrefix = "Copy \"";
	const std::string kParentPrefix = "Customize \"";

	for(int i = 1, end = intSize(sProfiles.size()); i < end; ++i)
	{
		if( sProfiles[i].valid() )
		{
			aLoadableProfileNames.push_back(sProfiles[i].name);
			aLoadableProfileIndexes.push_back(i);
			aTemplateProfileNames.push_back(
				kCopyFilePrefix + sProfiles[i].name + '"');
			aTemplateSourceFileIndexes.push_back(
				sProfiles[i].fileIDs[0]);
			aTemplateProfileType.push_back(eType_CopyFile);
		}
	}

	const bool needFirstProfile = aLoadableProfileNames.empty();
	for(int i = 0; i < ARRAYSIZE(kResTemplateCustom); ++i)
	{
		if( needFirstProfile )
		{
			aLoadableProfileNames.push_back(kResTemplateCustom[i].dispName);
			aLoadableProfileIndexes.push_back(i);
		}
		aTemplateProfileNames.push_back(
			kCopyFilePrefix + kResTemplateCustom[i].dispName + '"');
		aTemplateSourceFileIndexes.push_back(i);
		aTemplateProfileType.push_back(eType_CopyResCustom);
	}

	for(int i = 0, end = intSize(sKnownFiles.size()); i < end; ++i)
	{
		aTemplateProfileNames.push_back(
			kParentPrefix + sKnownFiles[i].name + '"');
		aTemplateSourceFileIndexes.push_back(i);
		aTemplateProfileType.push_back(eType_ParentFile);
	}

	for(int i = 0; i < ARRAYSIZE(kResTemplateBase); ++i)
	{
		// Only add ones that don't already exist in sKnownFiles
		bool alreadyExists = false;
		const ProfileFile& aTestEntry =
			profileNameToFile(kResTemplateBase[i].fileName);
		if( fileExists(aTestEntry) )
		{
			for(int j = 0, end = intSize(sKnownFiles.size()); j < end; ++j)
			{
				if( isSamePath(sKnownFiles[j].path, aTestEntry.path) )
				{
					alreadyExists = true;
					break;
				}
			}
		}
		if( alreadyExists )
			continue;
		aTemplateProfileNames.push_back(
			kParentPrefix + kResTemplateBase[i].dispName + '"');
		aTemplateSourceFileIndexes.push_back(i);
		aTemplateProfileType.push_back(eType_ParentResBase);
	}

	for(int i = 0; i < ARRAYSIZE(kResTemplateDefault); ++i)
	{
		bool alreadyExists = false;
		const ProfileFile& aTestEntry =
			profileNameToFile(kResTemplateDefault[i].fileName);
		if( fileExists(aTestEntry) )
		{
			for(int j = 0, end = intSize(sKnownFiles.size()); j < end; ++j)
			{
				if( isSamePath(sKnownFiles[j].path, aTestEntry.path) )
				{
					alreadyExists = true;
					break;
				}
			}
		}
		if( alreadyExists )
			continue;
		aTemplateProfileNames.push_back(
			kParentPrefix + kResTemplateDefault[i].dispName + '"');
		aTemplateSourceFileIndexes.push_back(i);
		aTemplateProfileType.push_back(eType_ParentResDefault);
	}

	// Use Dialog to ask the user what they want to do
	int aDefaultSelectedIdx = -1;
	if( !sLoadedProfileName.empty() )
	{
		for(int i = 0, end = intSize(aLoadableProfileNames.size());
			i < end; ++i)
		{
			if( aLoadableProfileNames[i] == sLoadedProfileName )
				aDefaultSelectedIdx = i;
		}
	}
	if( theLastCreatedProfileIdx >= 0 )
		aDefaultSelectedIdx = theLastCreatedProfileIdx;
	Dialogs::ProfileSelectResult aDialogResult = Dialogs::profileSelect(
		aLoadableProfileNames,
		aTemplateProfileNames,
		aDefaultSelectedIdx,
		sAutoLoadProfileID > 0 &&
			size_t(sAutoLoadProfileID) < sProfiles.size() &&
			sProfiles[sAutoLoadProfileID].valid(),
		needFirstProfile);

	if( aDialogResult.cancelled )
	{// User declined to select anything
		return result;
	}

	// For first profile, if no name given then use built-in name
	// NOTE: This only works out because set the first entries of
	// aTemplateProfile's to match aLoadableProfile's which both
	// match the entries in kResTemplateCustom. So need to change
	// this if rearrange the order of any of these above!
	if( needFirstProfile && aDialogResult.newName.empty() )
		aDialogResult.newName =
			kResTemplateCustom[aDialogResult.selectedIndex].fileName;

	if( aDialogResult.newName.empty() )
	{// User must have requested to load or edit an existing profile
		DBG_ASSERT(size_t(aDialogResult.selectedIndex) <
			aLoadableProfileNames.size());
		result = aLoadableProfileIndexes[aDialogResult.selectedIndex];
		setAutoLoadProfile(
			aDialogResult.autoLoadRequested ? result : 0);
		if( aDialogResult.editProfileRequested )
		{
			userEditProfile(result, false);
			result = -1; // repeat query from the start
		}
		return result;
	}

	// User must have requested creating a new profile
	const std::string& aNewName = extractProfileName(aDialogResult.newName);
	ProfileFile aNewEntry = profileNameToFile(aNewName);
	int aSrcIdx = aDialogResult.selectedIndex;
	DBG_ASSERT(size_t(aSrcIdx) < aTemplateSourceFileIndexes.size());

	if( fileExists(aNewEntry) )
	{// File already exists
		if( isSamePath(aNewEntry.path, sKnownFiles[0].path) )
		{
			Dialogs::showError(
				"Can not create custom Profile with the name 'Core'!");
			result = -1; // repeat query from the start
			return result;
		}
		int duplicateLoadProfileIdx = -1;
		for(int i = 0, end = intSize(sProfiles.size()); i < end; ++i)
		{
			if( !sProfiles[i].valid() )
				continue;
			const ProfileFile& aKnownFile =
				sKnownFiles[sProfiles[i].fileIDs[0]];
			if( sProfiles[i].valid() &&
				isSamePath(aKnownFile.path, aNewEntry.path) )
			{
				duplicateLoadProfileIdx = i;
				break;
			}
		}
		if( duplicateLoadProfileIdx >= 0 )
		{
			if( Dialogs::yesNoPrompt(strFormat(
					"Profile '%s' already exists. Overwrite?",
						aNewName.c_str()),
					"Overwrite existing Profile") != eResult_Yes )
			{
				result = -1; // repeat query from the start
				return result;
			}
			sProfiles[duplicateLoadProfileIdx].fileIDs.clear();
		}
		else
		{
			Dialogs::showError(strFormat(
				"File '%s' already exists and can't be overwritten "
				"because it is not listed in the profile list in '%s'. "
				"This may indicate it is profile's parent file.",
				getFileName(aNewEntry.path).c_str(), kCoreProfileName));
			result = -1; // repeat query from the start
			return result;
		}
	}

	DBG_ASSERT(size_t(aDialogResult.selectedIndex) <
		aTemplateProfileType.size());
	EType aProfileType = aTemplateProfileType[aDialogResult.selectedIndex];
	if( aProfileType == eType_ParentResDefault ||
		aProfileType == eType_CopyResCustom )
	{// Do not allow Base profile names for a new profile of these types
		// This is to prevent possibly having self as grandparent
		const std::string& aCompName = condense(aNewName);
		for(int i = 0; i < ARRAYSIZE(kResTemplateBase); ++i)
		{
			if( aCompName == condense(kResTemplateBase[i].fileName) )
			{
				Dialogs::showError(
					"Selected Profile name not valid (reserved)!");
				result = -1; // repeat query from the start
				return result;
			}
		}
	}

	if( aProfileType == eType_CopyResCustom )
	{// Do not allow Default profile names for a new profile of these types
		// This is to prevent possibly having self as a parent
		const std::string& aCompName = condense(aNewName);
		for(int i = 0; i < ARRAYSIZE(kResTemplateDefault); ++i)
		{
			if( aCompName == condense(kResTemplateDefault[i].fileName) )
			{
				Dialogs::showError(
					"Selected Profile name not valid (reserved)!");
				result = -1; // repeat query from the start
				return result;
			}
		}
	}

	// Find slot in sProfiles to add profile to
	result = intSize(sProfiles.size());
	for(int i = 1; i < result; ++i)
	{
		if( !sProfiles[i].valid() )
		{
			result = i;
			break;
		}
	}
	if( result == intSize(sProfiles.size()) )
		sProfiles.push_back(ProfileInfo());
	DBG_ASSERT(result > 0);

	switch(aProfileType)
	{
	case eType_CopyFile:
		{// Create copy of source file
			const int aKnownProfileIdx = aTemplateSourceFileIndexes[aSrcIdx];
			DBG_ASSERT(size_t(aKnownProfileIdx) < sKnownFiles.size());
			const ProfileFile& aSrcFile = sKnownFiles[aKnownProfileIdx];
			// Don't actually do anything if source and dest are the same file
			if( !isSamePath(aNewEntry.path, aSrcFile.path) )
			{
				CopyFile(
					widen(aSrcFile.path).c_str(),
					widen(aNewEntry.path).c_str(),
					FALSE);
			}
		}
		break;
	case eType_CopyResCustom:
		{// Generate resource profile but with new file name
			const int aResTemplateIdx = aTemplateSourceFileIndexes[aSrcIdx];
			DBG_ASSERT(aResTemplateIdx >= 0);
			DBG_ASSERT(aResTemplateIdx < ARRAYSIZE(kResTemplateCustom));
			ResourceFile aResFile = kResTemplateCustom[aResTemplateIdx];
			aResFile.fileName = aNewName.c_str();
			generateResourceFile(aResFile);
		}
		break;
	case eType_ParentResBase:
	case eType_ParentResDefault:
		{// Generate resource profile to act as parent
			const int aResBaseIdx = aTemplateSourceFileIndexes[aSrcIdx];
			const char* aProfileName = null;
			if( aProfileType == eType_ParentResDefault )
			{
				DBG_ASSERT(aResBaseIdx < ARRAYSIZE(kResTemplateDefault));
				generateResourceFile(kResTemplateDefault[aResBaseIdx]);
				aProfileName = kResTemplateDefault[aResBaseIdx].fileName;
			}
			else
			{
				DBG_ASSERT(aResBaseIdx < ARRAYSIZE(kResTemplateBase));
				generateResourceFile(kResTemplateBase[aResBaseIdx]);
				aProfileName = kResTemplateBase[aResBaseIdx].fileName;
			}
			sNewBaseProfileIdx = -1;
			sNewBaseProfileIdx = getOrAddKnownFileID(
				profileNameToFile(aProfileName));
			if( sNewBaseProfileIdx < 0 )
				break;
			// Treat as _ParentFile type now that resource exists as a file
			aTemplateProfileNames.push_back("");
			aTemplateSourceFileIndexes.push_back(sNewBaseProfileIdx);
			aTemplateProfileType.push_back(eType_ParentFile);
			aSrcIdx = intSize(aTemplateProfileType.size()) - 1;
			aNewEntry = profileNameToFile(aNewName);
		}
		// fall through
	case eType_ParentFile:
		{// Create new file that sets source file as its parent profile
			const int aKnownProfileIdx = aTemplateSourceFileIndexes[aSrcIdx];
			DBG_ASSERT(size_t(aKnownProfileIdx) < sKnownFiles.size());
			const ProfileFile& aSrcFile = sKnownFiles[aKnownProfileIdx];
			// Make sure parent and new file are not the same file
			if( isSamePath(aSrcFile.path, aNewEntry.path) )
			{
				Dialogs::showError(
					"Selected Profile name matches parent profile name!");
				result = -1; // repeat query from the start
				return result;
			}
			ResourceFile aResFile = kResTemplateBlank;
			aResFile.fileName = aNewEntry.name.c_str();
			generateResourceFile(aResFile);
			if( aKnownProfileIdx > 0 )
			{// Don't need to specify a parent if Core is the parent
				setPropertyInINI(
					aNewEntry.path, "",
					"ParentProfile", aSrcFile.name);
			}
		}
		break;
	}

	if( !fileExists(aNewEntry) )
	{
		Dialogs::showError(strFormat(
			"Failure creating new Profile '%s' (%s)!",
			aNewEntry.name.c_str(), aNewEntry.path.c_str()));
		result = -1; // repeat query from the start
		return result;
	}

	setPropertyInINI(
		sKnownFiles[0].path, "",
		std::string(kProfileKeyPrefix) + toString(result),
		aNewEntry.name);
	sProfiles[result].fileIDs.push_back(getOrAddKnownFileID(aNewEntry));
	sProfiles[result].name = aNewEntry.name;
	generateProfileLoadPriorityList(result);
	setAutoLoadProfile(aDialogResult.autoLoadRequested ? result : 0);
	theLastCreatedProfileIdx = result;

	// Extra prompts for first time create a "base" profile, which represents
	// the shared default values for all profiles for a particular game, and
	// thus need to set some of these default but game-specific settings
	if( sNewBaseProfileIdx >= 0 )
	{
		// Load defaults values from generated file
		const BaseGameSettings& aDefaultSettings =
			getBaseGameSettings(sKnownFiles[sNewBaseProfileIdx]);
		BaseGameSettings aSettings = aDefaultSettings;

		// Prompt user for auto-launch configuration
		Dialogs::targetAppPath(
			aSettings.autoLaunch.path,
			aSettings.autoLaunch.params);

		writeBaseGameSettingsChanges(
			sKnownFiles[sNewBaseProfileIdx],
			aDefaultSettings,
			aSettings);

		// Load read-in known issues key now, before rest of profile,
		// so can generate it and display it immediately
		generateKnownIssuesRTF(aDefaultSettings.knownIssuesList);
		if( sNeedShowKnownIssues )
		{
			Dialogs::showKnownIssues();
			sNeedShowKnownIssues = false;
		}
	}
	sNewBaseProfileIdx = -1;

	if( needFirstProfile )
	{
		if( Dialogs::yesNoPrompt(
				"Would you like to edit this Profile now to match your in-game "
				"Key Binds and other settings?",
				"Edit new profile") == eResult_Yes )
		{
			userEditProfile(result, true);
		}
		else
		{
			return result;
		}
	}

	// Query again to actually load the new profile
	result = -1;
	return result;
}


static int queryUserForProfileID()
{
	saveChangesToFile();
	if( sKnownFiles.empty() )
		parseProfilesCanLoad();
	int aLastCreatedProfileIdx = -1;
	int result = -1;
	while(result < 0)
		result = queryUserForProfileImpl(aLastCreatedProfileIdx);
	return result;
}



//------------------------------------------------------------------------------
// Global Functions
//------------------------------------------------------------------------------

void loadCore()
{
	// Should only be run once at app startup, otherwise core will be
	// loaded alongside normal ::load()
	initSectionMap();
	ProfileFile aCoreFile = profileNameToFile(kCoreProfileName);
	if( !fileExists(aCoreFile) )
	{// Core .ini file not found!
		// Assume this means first run, which means show license agreement
		if( Dialogs::showLicenseAgreement() == eResult_Declined )
		{// Declined license agreement - just exit
			gShutdown = true;
		}
		else
		{// Generate Core.ini which will prevent future license agreement
			generateResourceFile(kResTemplateCore);
			if( !fileExists(aCoreFile) )
			{
				logFatalError("Unable to find/write %s (%s)",
					kCoreProfileName, aCoreFile.path.c_str());
			}
		}
	}
	if( hadFatalError() || gShutdown )
		return;

	parseINI(
		readProfileCallback,
		aCoreFile.path,
		eParseMode_Sections);
}


void load()
{
	parseProfilesCanLoad();
	if( hadFatalError() || gShutdown )
		return;

	int aProfileIDToLoad = -1;
	if( gProfileToLoad.empty() )
	{// Use auto-load or query for initial profile to load
		if( sAutoLoadProfileID )
		{
			if( size_t(sAutoLoadProfileID) >= sProfiles.size() ||
				!sProfiles[sAutoLoadProfileID].valid() )
			{
				Dialogs::showError(strFormat(
					"AutoLoadProfile = %d but no profile #%d found!",
					sAutoLoadProfileID, sAutoLoadProfileID));
				sAutoLoadProfileID = 0;
			}
			else
			{
				aProfileIDToLoad = sAutoLoadProfileID;
			}
		}
		if( !sAutoLoadProfileID )
			aProfileIDToLoad = queryUserForProfileID();
	}
	else
	{// Find the requested profile name and load it
		for(int i = 0, end = intSize(sProfiles.size()); i < end; ++i)
		{
			if( sProfiles[i].name == gProfileToLoad )
			{
				aProfileIDToLoad = i;
				break;
			}
		}
	}

	if( aProfileIDToLoad <= 0 )
	{// Nothing was selected to load - exit app entirely
		gShutdown = true;
		return;
	}

	sSectionsMap.clear();
	initSectionMap();
	// Prepare for reading known issues
	sNeedShowKnownIssues = false;
	sKnownIssuesRTF.clear();

	DBG_ASSERT(size_t(aProfileIDToLoad) < sProfiles.size());
	const std::vector<int>& aList = sProfiles[aProfileIDToLoad].fileIDs;
	DBG_ASSERT(!aList.empty());

	// Now load each .ini's values 1-by-1 in reverse order.
	// Any setting in later files overrides previous setting,
	// which is why we load them in reverse of priority order
	for(std::vector<int>::const_reverse_iterator itr = aList.rbegin();
		itr != aList.rend(); ++itr)
	{
		DBG_ASSERT(size_t(*itr) < sKnownFiles.size());
		checkForOutdatedFileVersion(sKnownFiles[*itr]);
		parseINI(
			readProfileCallback,
			sKnownFiles[*itr].path,
			eParseMode_Sections);
	}
	sSectionsMap.trim();

	// Process variable expansion for all properties
	for(int aSectionID = 0; aSectionID < sSectionsMap.size(); ++aSectionID)
	{
		PropertyMap& aSection = sSectionsMap.vals()[aSectionID];
		for(int aPropID = 0; aPropID < aSection.size(); ++aPropID)
			expandPropertyVars(aSectionID, aPropID, true);
	}

	// Sort and remove duplicate entries in variable dependency list
	std::sort(sVarPropDepList.begin(), sVarPropDepList.end());
	sVarPropDepList.erase(
		std::unique(sVarPropDepList.begin(), sVarPropDepList.end()),
		sVarPropDepList.end());

	// Now that have loaded a profile, only need to remember the loaded
	// profile's name and can forget gathered data about other profiles
	sLoadedProfileName = sProfiles[aProfileIDToLoad].name;
	sKnownFiles.clear();
	sProfiles.clear();
	sAutoLoadProfileID = 0;
	sNewBaseProfileIdx = -1;
	gProfileToLoad.clear();
}


std::string queryUserForProfile()
{
	int aProfileID = queryUserForProfileID();
	if( size_t(aProfileID) < sProfiles.size() )
		return sProfiles[aProfileID].name;
	return std::string();
}


std::string userEditCurrentProfile()
{
	saveChangesToFile();
	if( sKnownFiles.empty() )
		parseProfilesCanLoad();
	for(int i = 0, end = intSize(sProfiles.size()); i < end; ++i)
	{
		if( sProfiles[i].name == sLoadedProfileName )
		{
			if( userEditProfile(1, false) )
				return sLoadedProfileName;
		}
	}

	return std::string();
}


const std::string& getKnownIssuesRTF()
{
	if( sKnownIssuesRTF.empty() )
	{
		generateKnownIssuesRTF(getStr(
			kBaseGameSettingsSection, kKnownIssuesKey));
	}
	sNeedShowKnownIssues = false;
	return sKnownIssuesRTF;
}


std::string getStr(
	const std::string& theSection,
	const std::string& thePropertyName,
	const std::string& theDefaultValue)
{
	if( const PropertyMap* aSection = sSectionsMap.find(theSection) )
	{
		if( const Property* aProp = aSection->find(thePropertyName) )
		{
			if( !aProp->str.empty() )
				return aProp->str;
		}
	}

	return theDefaultValue;
}


int getInt(
	const std::string& theSection,
	const std::string& theName,
	int theDefaultValue)
{
	const std::string& aStr = getStr(theSection, theName);
	if( !aStr.empty() )
		return stringToInt(aStr);
	return theDefaultValue;
}


bool getBool(
	const std::string& theSection,
	const std::string& theName,
	bool theDefaultValue)
{
	const std::string& aStr = getStr(theSection, theName);
	if( !aStr.empty() )
		return stringToBool(aStr);
	return theDefaultValue;
}


double getFloat(
	const std::string& theSection,
	const std::string& theName,
	double theDefaultValue)
{
	const std::string& aStr = getStr(theSection, theName);
	if( !aStr.empty() )
		return stringToDouble(aStr);
	return theDefaultValue;
}


int variableNameToID(const std::string& theVarName)
{
	int result = sSectionsMap.vals()[kVarsSectionIdx].findIndex(theVarName);
	if( result >= sSectionsMap.vals()[kVarsSectionIdx].size() )
		result = -1;
	return result;
}


std::string variableIDToName(int theVariableID)
{
	DBG_ASSERT(theVariableID >= 0);
	DBG_ASSERT(theVariableID < sSectionsMap.vals()[kVarsSectionIdx].size());
	return sSectionsMap.vals()[kVarsSectionIdx].keys()[theVariableID];
}


std::string getVariable(int theVariableID)
{
	DBG_ASSERT(theVariableID >= 0);
	DBG_ASSERT(theVariableID < sSectionsMap.vals()[kVarsSectionIdx].size());
	return sSectionsMap.vals()[kVarsSectionIdx].vals()[theVariableID].str;
}


std::string getVariable(const std::string& theVarName)
{
	return getStr(getSectionProperties(kVarsSectionIdx), theVarName);
}


std::string expandVars(std::string theString)
{
	std::string result;
	PropertyMap& theVarsMap = sSectionsMap.vals()[kVarsSectionIdx];
	std::pair<std::string::size_type, std::string::size_type> aTagCoords =
		findStringTag(theString, 0, "${", '}');

	while( aTagCoords.first != std::string::npos )
	{
		// Extract variable name from tag
		size_t aVarOpPos = aTagCoords.first + 2;
		const std::string& aVarName =
			fetchNextItem(theString, aVarOpPos, "}+-*/?!~<>=");
		const int aVarID = theVarsMap.findIndex(aVarName);
		if( aVarOpPos < aTagCoords.first + aTagCoords.second &&
			!aVarName.empty() && aVarID < theVarsMap.size() )
		{
			const std::string& aRepStr = varTagToString(
				theVarsMap.vals()[aVarID].str,
				theString, aVarOpPos);
			theString = theString.replace(
				aTagCoords.first, aTagCoords.second, aRepStr);
			aTagCoords = findStringTag(theString, 0, "${", '}');
		}
		else
		{
			return theString;
		}
	}

	return theString;
}


int getSectionID(const std::string& theSectionName)
{
	int result = sSectionsMap.findIndex(theSectionName);
	if( result >= sSectionsMap.size() )
		result = -1;
	return result;
}


PropertyMapPtr getSectionProperties(const std::string& theSectionName)
{
	return getSectionProperties(getSectionID(theSectionName));
}


PropertyMapPtr getSectionProperties(int theSectionID)
{
	static const PropertyMap kEmptyMap = PropertyMap();
	if( theSectionID >= 0 && theSectionID < sSectionsMap.size() )
		return &sSectionsMap.vals()[theSectionID];
	return &kEmptyMap;
}


const SectionsMap& allSections()
{
	return sSectionsMap;
}


std::string getStr(
	PropertyMapPtr theSection,
	const std::string& thePropertyName,
	const std::string& theDefaultValue)
{
	if( const Property* aProp = theSection->find(thePropertyName) )
	{
		if( !aProp->str.empty() )
			return aProp->str;
	}

	return theDefaultValue;
}


int getInt(
	PropertyMapPtr theSection,
	const std::string& theName,
	int theDefaultValue)
{
	const std::string& aStr = getStr(theSection, theName);
	if( !aStr.empty() )
		return stringToInt(aStr);
	return theDefaultValue;
}


bool getBool(
	PropertyMapPtr theSection,
	const std::string& theName,
	bool theDefaultValue)
{
	const std::string& aStr = getStr(theSection, theName);
	if( !aStr.empty() )
		return stringToBool(aStr);
	return theDefaultValue;
}


double getFloat(
	PropertyMapPtr theSection,
	const std::string& theName,
	double theDefaultValue)
{
	const std::string& aStr = getStr(theSection, theName);
	if( !aStr.empty() )
		return stringToDouble(aStr);
	return theDefaultValue;
}


void setStr(
	const std::string& theSection,
	const std::string& thePropertyName,
	const std::string& theValue,
	bool saveToFile)
{
	confirmSafeToWriteToMap();
	const int aSectionID = sSectionsMap.findOrAddIndex(theSection);
	PropertyMap& aSection = sSectionsMap.vals()[aSectionID];
	const int aPropID = aSection.findOrAddIndex(thePropertyName);
	setPropertyAfterLoad(aSectionID, aPropID, theValue, saveToFile);
}


void setStr(
	int theSectionID,
	const std::string& thePropertyName,
	const std::string& theValue,
	bool saveToFile)
{
	confirmSafeToWriteToMap();
	DBG_ASSERT(theSectionID >= 0 && theSectionID < sSectionsMap.size());
	PropertyMap& aSection = sSectionsMap.vals()[theSectionID];
	const int aPropID = aSection.findOrAddIndex(thePropertyName);
	setPropertyAfterLoad(theSectionID, aPropID, theValue, saveToFile);
}


void setVariable(int theVarID, const std::string& theValue, bool temporary)
{
	confirmSafeToWriteToMap();
	setPropertyAfterLoad(kVarsSectionIdx, theVarID, theValue, !temporary);
}


void setVariable(
	const std::string& theVarName,
	const std::string& theValue,
	bool temporary)
{
	confirmSafeToWriteToMap();
	const int theVarID =
		sSectionsMap.vals()[kVarsSectionIdx].findOrAddIndex(theVarName);
	setPropertyAfterLoad(kVarsSectionIdx, theVarID, theValue, !temporary);
}


void setNewStr(
	const std::string& theSection,
	const std::string& thePropertyName,
	const std::string& theValue)
{
	if( getStr(theSection, thePropertyName) == "" )
		setStr(theSection, thePropertyName, theValue);
}


const SectionsMap& changedSections()
{
	return sChangedSectionsMap;
}


void clearChangedSections()
{
	sChangedSectionsMap.clear();
}


void saveChangesToFile()
{
	if( sUnsavedChangesList.empty() || sLoadedProfileName.empty() )
		return;
	const std::string& aFilePath = profileNameToFilePath(sLoadedProfileName);
	for(int i = 0, end = intSize(sUnsavedChangesList.size()); i < end; ++i)
	{
		const std::string& aSectionName =
			sSectionsMap.keys()[sUnsavedChangesList[i].sectionID];
		const PropertyMap& aPropMap =
			sSectionsMap.vals()[sUnsavedChangesList[i].sectionID];
		const std::string& aPropName =
			aPropMap.keys()[sUnsavedChangesList[i].propertyID];
		const std::string& aPropValue = sUnsavedChangesList[i].value;

		setPropertyInINI(aFilePath, aSectionName, aPropName, aPropValue);
	}
	sUnsavedChangesList.clear();
}

} // Profile
