//-----------------------------------------------------------------------------
//	Originally written by Taron Millet, except where otherwise noted
//-----------------------------------------------------------------------------

#include "Profile.h"

#include "Dialogs.h"
#include "Resources/resource.h"

#include <fstream>

namespace Profile
{

//-----------------------------------------------------------------------------
// Const Data
//-----------------------------------------------------------------------------

enum {
kINIFileBufferSize = 4096, // How many chars to process at a time from .ini
};

const char* kProfileFileNamePrefix = "MMOGO_";
const char* kProfileFileNameSuffix = ".ini";
const char* kProfileKeyPrefix = "Profile";
const char* kCoreProfileName = "MMOGO_Core.ini";
const char* kBaseGameSettingsSection = "System";
const char* kAutoLaunchAppKey = "AutoLaunchApp";
const char* kAutoLaunchAppParamsKey = "AutoLaunchAppParams";
const char* kXInputFixKey = "XInputFix";
const char* kAutoLoadProfileKey = "AutoLoadProfile";
const char* kAutoGenVersionKey = "AutoGeneratedVersion";
const char* kVariablesSectionName = "Variables";
const int kVarsSectionIdx = 0;
const std::string kEndOfLine = "\r\n";

struct ResourceProfile
{
	const char* dispName;
	const char* fileName;
	WORD resID;
	int version;
};

const ResourceProfile kResTemplateCore =
	{	"Core",							"Core",				IDR_TEXT_INI_CORE,		6	};

const ResourceProfile kResTemplateBase[] =
{//		dispName						fileName			resID					ver
	{	"AOA Base",						"AOA Base",			IDR_TEXT_INI_BASE_AOA,	6	},
	{	"EQ P99 Base",					"P99 Base",			IDR_TEXT_INI_BASE_P99,	6	},
	{	"EQ PQ Base",					"PQ Base",			IDR_TEXT_INI_BASE_PQ,	6	},
	{	"M&M Base",						"MnM Base",			IDR_TEXT_INI_BASE_MNM,	6	},
	{	"Pantheon Base",				"Pantheon Base",	IDR_TEXT_INI_BASE_PAN,	6	},
};

const ResourceProfile kResTemplateDefault[] =
{//		dispName						fileName			resID					ver
	{	"AOA Default",					"AOA Default",		IDR_TEXT_INI_DEF_AOA,	6	},
	{	"EQ P99 Default",				"P99 Default",		IDR_TEXT_INI_DEF_P99,	6	},
	{	"EQ PQ Default",				"PQ Default",		IDR_TEXT_INI_DEF_PQ,	6	},
	{	"M&M Default",					"MnM Default",		IDR_TEXT_INI_DEF_MNM,	6	},
	{	"Pantheon Default",				"Pantheon Default",	IDR_TEXT_INI_DEF_PAN,	6	},
};

const ResourceProfile kResTemplateCustom[] =
{//		dispName						fileName			resID					ver
	{	"Adrullan Online Adventures",	"AOA",				IDR_TEXT_INI_CUST_AOA,	0	},
	{	"EverQuest: Project 1999",		"P99",				IDR_TEXT_INI_CUST_P99,	0	},
	{	"EverQuest: Project Quarm",		"PQ",				IDR_TEXT_INI_CUST_PQ,	0	},
	{	"Monsters & Memories",			"MnM",				IDR_TEXT_INI_CUST_MNM,	0	},
	{	"Pantheon: Rise of the Fallen",	"Pantheon",			IDR_TEXT_INI_CUST_PAN,	0	},
};

enum EParseMode
{
	eParseMode_Header,
	eParseMode_Sections,
};

struct ProfileEntry
{
	std::string name;
	std::string path;
};

typedef void (*ParseINICallback)(
	const std::string& theSection,
	const std::string& theName,
	const std::string& theValue,
	void* theUserData);

struct UnsavedProperty
{
	std::string section;
	std::string name;
	std::string val;
};

struct VarPropDependency
{
	u32 varID : 9;
	u32 sectID : 9;
	u32 propID : 14;

	u32 cmpVal() const { return (varID << 23) | (sectID << 14) | propID; }
    bool operator<(const VarPropDependency& rhs) const
	{ return cmpVal() < rhs.cmpVal(); }
    bool operator==(const VarPropDependency& rhs) const
	{ return cmpVal() == rhs.cmpVal(); }
};

struct BaseGameSettings
{
	struct AutoLaunch
	{
		std::string path;
		std::string params;
	} autoLaunch;
	struct ZERO_INIT(XInputFix)
	{
		std::string dirPath;
		std::string gameName;
		std::string exeName;
		std::string launcherName;
		bool use64BitVersion;
		bool shouldUse;
		bool userWants;
	} xInputFix;
};


//-----------------------------------------------------------------------------
// Static Variables
//-----------------------------------------------------------------------------

static SectionsMap sSectionsMap;
static SectionsMap sChangedSectionsMap;
static std::vector<UnsavedProperty> sUnsavedChangesList;
static std::vector<ProfileEntry> sKnownProfiles;
static std::vector< std::vector<int> > sProfilesCanLoad;
static std::vector<VarPropDependency> sVarPropDepList;
static std::string sLoadedProfileName;
static int sAutoProfileIdx = 0;
static int sNewBaseProfileIdx = -1;


//-----------------------------------------------------------------------------
// Local Functions
//-----------------------------------------------------------------------------

static const std::string& iniFolderPath()
{
	static std::string sFolderPath;
	if( sFolderPath.empty() )
	{
		// Just use our application folder (for now)
		sFolderPath = getAppFolder();

		// Make sure it actually exists
		// (obviously it has to, but leaving this here for possibly
		// later changing the .ini folder to AppData or something)
		size_t aCurPos = 0;
		for(;;)
		{
			size_t aSlashPos = sFolderPath.find_first_of("\\/", aCurPos);
			if( aSlashPos == std::string::npos )
			{
				_wmkdir(widen(sFolderPath).c_str());
				break;
			}

			aCurPos = aSlashPos + 1;

			std::string aCurPath = sFolderPath.substr(0, aSlashPos);
			_wmkdir(widen(aCurPath).c_str());
		}
	}

	return sFolderPath;
}


static std::string extractProfileName(const std::string& theString)
{
	std::string result = removeExtension(getFileName(theString));
	const std::string& prefix = upper(kProfileFileNamePrefix);
	if( upper(result).compare(0, prefix.length(), upper(prefix)) == 0 )
		result = result.substr(prefix.length());
	return replaceChar(result, '_', ' ');
}


static std::string profileNameToFilePath(const std::string& theName)
{
	DBG_ASSERT(theName == extractProfileName(theName));
	std::string result = iniFolderPath();
	result += kProfileFileNamePrefix;
	result += replaceChar(theName, ' ', '_');
	result += kProfileFileNameSuffix;
	return result;
}


static bool profileExists(const std::string& theFilePath)
{
	return isValidFilePath(theFilePath);
}


static bool profileExists(const ProfileEntry& theEntry)
{
	return profileExists(theEntry.path);
}


static ProfileEntry profileNameToEntry(const std::string& theProfileName)
{
	ProfileEntry anEntry;
	anEntry.name = extractProfileName(theProfileName);
	anEntry.path = profileNameToFilePath(anEntry.name);
	return anEntry;
}


static int getOrAddProfileIdx(const ProfileEntry& theProfileEntry)
{
	// A map would be faster, but requires a separate Map structure
	// to ensure stable indexes (or using pointers instead), and
	// there's unlikely to be a whole lot of these anyway.
	for(int i = 0, end = intSize(sKnownProfiles.size()); i < end; ++i)
	{
		if( isSamePath(sKnownProfiles[i].path, theProfileEntry.path) )
			return i;
	}

	sKnownProfiles.push_back(theProfileEntry);
	return intSize(sKnownProfiles.size()) - 1;
}


static void parseINI(
	ParseINICallback theCallbackFunc,
	const std::string& theFilePath,
	EParseMode theParseMode,
	void* theUserData = NULL)
{
	std::ifstream aFile(widen(theFilePath).c_str(), std::ios::binary);
	if( !aFile.is_open() )
	{
		logFatalError("Could not open file %s", theFilePath.c_str());
		return;
	}

	// Prepare input buffer
	// +1 on size is to accommodate an extra newline character when
	// reach end of file
	char aBuffer[kINIFileBufferSize+1];
	std::streamsize aBufferSize = kINIFileBufferSize;
	std::string aNewSection;
	std::string aSection;
	std::string aKey;
	std::string aValue;

	enum
	{
		ePIState_Whitespace,
		ePIState_Section,
		ePIState_Key,
		ePIState_Value,
		ePIState_Comment,
	} aState = ePIState_Whitespace;

	while(aFile.good())
	{
		// Read next chunk from file
		aFile.read(aBuffer, aBufferSize);
		if( aFile.eof() || aFile.gcount() < aBufferSize )
		{// Put eol at end of file in case there wasn't one already
			aBufferSize = aFile.gcount() + 1;
			aBuffer[aBufferSize-1] = '\n';
			DBG_ASSERT(aBufferSize <= ARRAYSIZE(aBuffer));
		}
		else if( aFile.bad() )
		{
			logFatalError("Unknown error reading %s", theFilePath.c_str());
			aFile.close();
			return;
		}

		for(int i = 0; i < aBufferSize; ++i)
		{// Step through buffer character-by-character
			const char c = aBuffer[i];
			switch(aState)
			{
			case ePIState_Whitespace:
				// Look for a section, key, or comment
				if( c == '[' )
				{
					if( theParseMode == eParseMode_Header )
					{// Stop parsing once hit [ in this mode
						aFile.close();
						return;
					}
					aState = ePIState_Section;
					aNewSection.clear();
				}
				else if( c == '#' || c == ';' )
				{
					aState = ePIState_Comment;
				}
				else if( u8(c) > ' ' )
				{
					if( theParseMode == eParseMode_Sections &&
						aSection.empty() )
					{// Treat anything before first section as a comment
						aState = ePIState_Comment;
					}
					else
					{
						aState = ePIState_Key;
						aKey.clear();
						aKey.push_back(c);
					}
				}
				break;

			case ePIState_Section:
				// Look for end of line after ']' to end section
				switch(c)
				{
				case '\r': case '\n': case '\0':
					aNewSection = trim(aNewSection);
					if( aNewSection.size() > 1 &&
						aNewSection[aNewSection.size()-1] == ']' )
					{
						aNewSection.resize(aNewSection.size()-1);
						aSection.swap(aNewSection);
					}
					aState = ePIState_Whitespace;
					break;
				default:
					aNewSection.push_back(c);
				}
				break;

			case ePIState_Key:
				// Look for '=' to end key
				if( c == '=' )
				{// Switch from parsing key to value
					aKey = trim(aKey);
					aState = ePIState_Value;
					aValue.clear();
				}
				else if( c == '\r' || c == '\n' || c == '\0' )
				{// Abort - invalid key
					aState = ePIState_Whitespace;
				}
				else
				{
					aKey.push_back(c);
				}
				break;

			case ePIState_Value:
				// Look for eol to end value
				if( c == '\r' || c == '\n' || c == '\0' )
				{// Value string complete, time to process it!
					aValue = trim(aValue);
					theCallbackFunc(aSection, aKey, aValue, theUserData);
					aState = ePIState_Whitespace;
				}
				else
				{
					aValue.push_back(c);
				}
				break;

			case ePIState_Comment:
				// Look for eol to end comment
				if( c == '\r' || c == '\n' || c == '\0' )
					aState = ePIState_Whitespace;
				break;
			}
		}
	}

	aFile.close();
}


static void setPropertyInINI(
	const std::string& theFilePath,
	const std::string& theSection,
	const std::string& theKey,
	const std::string& theValue)
{
	// Open source file
	const std::wstring& aFilePathW = widen(theFilePath);
	std::ifstream aFile(aFilePathW.c_str(), std::ios::binary);
	if( !aFile.is_open() )
	{
		logError("Could not open file %s", theFilePath.c_str());
		return;
	}

	// Create temp output file
	const std::wstring& aTmpPath = getTempFilePathFor(aFilePathW);
	std::ofstream aTmpFile(
		aTmpPath.c_str(),
		std::ios::binary | std::ios::trunc);
	if( !aTmpFile.is_open() )
	{
		logError("Could not create temp file %s", narrow(aTmpPath).c_str());
		aFile.close();
		return;
	}

	// Prepare buffer
	// +1 on size is to accommodate an extra newline character when
	// reach end of file
	char aBuffer[kINIFileBufferSize+1];
	std::streamsize aBufferSize = kINIFileBufferSize;
	std::string aCheckStr;
	const std::string& aCmpSection = condense(theSection);
	const std::string& aCmpKey = condense(theKey);

	enum
	{
		eSKVState_FindSection,
		eSKVState_CheckSection,
		eSKVState_SkipSectionLine,
		eSKVState_FindKey,
		eSKVState_CheckKey,
		eSKVState_FinishKeyLine,
		eSKVState_SkipKeyLine,
		eSKVState_ValueLine,
		eSKVState_Finished,
	} aState = eSKVState_FindSection;

	// Parse the INI file to find start and end of segment to replace
	const std::fstream::pos_type kInvalidFilePos = -1;
	std::fstream::pos_type aReplaceStartPos = kInvalidFilePos;
	std::fstream::pos_type aReplaceEndPos = kInvalidFilePos;
	std::fstream::pos_type anEndOfValidSection = kInvalidFilePos;
	std::fstream::pos_type aCurrFilePos = aFile.tellg();
	std::fstream::pos_type aLastNonWhitespace = aCurrFilePos;

	if( theSection.empty() )
	{
		aState = eSKVState_FindKey;
		anEndOfValidSection = 0;
	}

	while(aFile.good() && aState != eSKVState_Finished)
	{
		// Read next chunk from file
		aFile.read(aBuffer, aBufferSize);
		if( aFile.eof() || aFile.gcount() < aBufferSize )
		{// Put eol at end of file in case there wasn't one already
			aBufferSize = aFile.gcount() + 1;
			aBuffer[aBufferSize-1] = '\n';
			DBG_ASSERT(aBufferSize <= ARRAYSIZE(aBuffer));
		}
		else if( aFile.bad() )
		{
			logError("Unknown error reading %s", theFilePath.c_str());
			aFile.close();
			return;
		}

		for(int i = 0; i < aBufferSize && aState != eSKVState_Finished; ++i)
		{// Step through buffer character-by-character
			const char c = aBuffer[i];
			if( u8(c) > ' ' )
				aLastNonWhitespace = aCurrFilePos;
			switch(aState)
			{
			case eSKVState_FindSection:
				// Look for a section
				if( c == '[' )
				{
					aState = eSKVState_CheckSection;
					aCheckStr.clear();
				}
				else if( u8(c) > ' ' )
				{
					aState = eSKVState_SkipSectionLine;
				}
				break;

			case eSKVState_CheckSection:
				// Look for endline after ']' to end section
				switch(c)
				{
				case '\r': case '\n': case '\0':
					aState = eSKVState_FindSection;
					aCheckStr = condense(aCheckStr);
					if( aCheckStr.size() > 1 &&
						aCheckStr[aCheckStr.size()-1] == ']' )
					{
						aCheckStr.resize(aCheckStr.size()-1);
						if( aCheckStr == aCmpSection )
						{
							aState = eSKVState_FindKey;
							anEndOfValidSection = aCurrFilePos;
						}
						else if( aCmpSection.empty() )
						{
							aState = eSKVState_Finished;
						}
					}
					break;
				default:
					aCheckStr.push_back(c);
					break;
				}
				break;

			case eSKVState_SkipSectionLine:
				// Look for end of line than resume section search
				if( c == '\r' || c == '\n' || c == '\0' )
					aState = eSKVState_FindSection;
				break;

			case eSKVState_FindKey:
				// Look for start of a key
				if( c == '[' )
				{
					aState = eSKVState_CheckSection;
					aCheckStr.clear();
				}
				else if( c == '#' || c == ';' )
				{
					aState = eSKVState_SkipKeyLine;
				}
				else if( u8(c) > ' ' )
				{
					aState = eSKVState_CheckKey;
					aCheckStr.clear();
					aCheckStr.push_back(c);
				}
				break;

			case eSKVState_CheckKey:
				// Look for '=' to end key
				if( c == '=' )
				{// End of the key - check if this is the one being looked for
					if( condense(aCheckStr) == aCmpKey )
					{// Found starting position to replace with new characters!
						aReplaceStartPos = aCurrFilePos;
						aReplaceStartPos += std::fstream::off_type(1);
						aState = eSKVState_ValueLine;
					}
					else
					{// Not the right key, but could be last key of section
						aState = eSKVState_FinishKeyLine;
					}
				}
				else if( c == '\r' || c == '\n' || c == '\0' )
				{// Abort - invalid key
					aState = eSKVState_FindKey;
				}
				else
				{
					aCheckStr.push_back(c);
				}
				break;

			case eSKVState_FinishKeyLine:
				// Continue to end of line then resume key search
				if( c == '\r' || c == '\n' || c == '\0' )
				{
					aState = eSKVState_FindKey;
					anEndOfValidSection = aCurrFilePos;
				}
				break;

			case eSKVState_SkipKeyLine:
				// Look for end of line then resume key search
				if( c == '\r' || c == '\n' || c == '\0' )
					aState = eSKVState_FindKey;
				break;

			case eSKVState_ValueLine:
				// Look for eol to end section to replace
				if( c == '\r' || c == '\n' || c == '\0' )
				{
					aReplaceEndPos = aCurrFilePos;
					aState = eSKVState_Finished;
				}
				break;
			}
			aCurrFilePos += std::fstream::off_type(1);
		}
	}

	// Clear eof flag
	aFile.clear();

	// Decide what to write and where exactly from info gathered above
	std::string aWriteString;
	if( aReplaceStartPos != kInvalidFilePos )
	{
		// Found the existing key, just write new value
		DBG_ASSERT(aReplaceEndPos != kInvalidFilePos);
		aWriteString = std::string(" ") + trim(theValue);
	}
	else if( anEndOfValidSection == std::fstream::pos_type(0) )
	{
		// Write new entry right at start of the file
		DBG_ASSERT(theSection.empty());
		aReplaceStartPos = aReplaceEndPos = 0;
		aWriteString = trim(theKey) + " = " + trim(theValue) + kEndOfLine;
	}
	else if( anEndOfValidSection != kInvalidFilePos )
	{
		// Found section, write key and value
		aReplaceStartPos = aReplaceEndPos = anEndOfValidSection;
		aWriteString = kEndOfLine + trim(theKey) + " = " + trim(theValue);
	}
	else
	{
		// Found nothing, write section, key, and value
		aReplaceStartPos = aLastNonWhitespace;
		aReplaceStartPos += std::fstream::off_type(1);
		aFile.seekg(0, std::ios::end);
		aReplaceEndPos = aFile.tellg();
		aWriteString = kEndOfLine + kEndOfLine + "[";
		aWriteString += trim(theSection) + "]" + kEndOfLine;
		aWriteString += trim(theKey) + " = " + trim(theValue);
		aWriteString += kEndOfLine;
	}

	// Write aFile 0->aReplaceStartPos to temp file
	aFile.seekg(0, std::ios::beg);
	aCurrFilePos = aFile.tellg();
	while(aCurrFilePos < aReplaceStartPos && aFile.good())
	{
		std::streamsize aBytesToRead = aReplaceStartPos - aCurrFilePos;
		aBytesToRead = MIN(aBytesToRead, kINIFileBufferSize);
		aFile.read(aBuffer, aBytesToRead);
		aTmpFile.write(aBuffer, aFile.gcount());
		aCurrFilePos += aFile.gcount();
	}

	// Write new data
	aTmpFile << aWriteString;

	// Write aReplaceEndPos->eof to temp file
	aFile.seekg(aReplaceEndPos, std::ios::beg);
	while(aFile.read(aBuffer, kINIFileBufferSize))
		aTmpFile.write(aBuffer, aFile.gcount());
	aTmpFile.write(aBuffer, aFile.gcount());

	// Close both files
	aFile.close();
	aTmpFile.close();

	// Replace original file with temp file (temp file is moved/consumed)
	if( !ReplaceFile(aFilePathW.c_str(), aTmpPath.c_str(),
			NULL, REPLACEFILE_IGNORE_MERGE_ERRORS, NULL, NULL) )
	{
		logError("Failed to modify file %s!", theFilePath.c_str());
	}
}


static void generateResourceProfile(const ResourceProfile& theResProfile)
{
	const std::string& aFilePath =
		profileNameToFilePath(theResProfile.fileName);

	if( !writeResourceToFile(theResProfile.resID,
			L"TEXT", widen(aFilePath).c_str()) )
	{
		logFatalError("Unable to write Profile data to file %s\n",
			aFilePath.c_str());
		return;
	}

	if( theResProfile.version )
	{
		setPropertyInINI(aFilePath,
			"", kAutoGenVersionKey,
			toString(theResProfile.version));
	}
}


static void getProfileListCallback(
	const std::string& theSection,
	const std::string& theName,
	const std::string& theValue,
	void*)
{
	if( theValue.empty() )
		return;
	DBG_ASSERT(theSection.empty());
	const std::string& aProfileNameKey = condense(theName);
	const std::string& aProfileKeyPrefix = condense(kProfileKeyPrefix);
	if( aProfileNameKey.compare(0,
			aProfileKeyPrefix.length(), aProfileKeyPrefix) == 0 )
	{// Profile name entry
		const int aProfileNum =
			intFromString(aProfileNameKey.substr(aProfileKeyPrefix.length()));
		if( aProfileNum > 0 && !theValue.empty() )
		{
			const ProfileEntry& aProfileEntry = profileNameToEntry(theValue);
			if( profileExists(aProfileEntry) )
			{
				if( aProfileNum >= intSize(sProfilesCanLoad.size()) )
					sProfilesCanLoad.resize(aProfileNum + 1);
				sProfilesCanLoad[aProfileNum].push_back(
					getOrAddProfileIdx(aProfileEntry));
			}
			else
			{
				logError("Could not find/open profile '%s' (%s) listed in %s",
					theValue.c_str(),
					aProfileEntry.path.c_str(),
					kCoreProfileName);
			}
		}
	}
	else if( aProfileNameKey == condense(kAutoLoadProfileKey) )
	{// Auto-load profile entry
		if( theValue.empty() )
			return;

		int anAutoProfileNum = intFromString(theValue);
		if( anAutoProfileNum > 0 &&
			toString(anAutoProfileNum).length() == theValue.length() )
		{// Specified by number
			sAutoProfileIdx = anAutoProfileNum;
			return;
		}

		// Specified by name
		const ProfileEntry& aProfileEntry = profileNameToEntry(theValue);
		if( profileExists(aProfileEntry) )
		{
			DBG_ASSERT(!sProfilesCanLoad.empty());
			sProfilesCanLoad[0].push_back(
				getOrAddProfileIdx(aProfileEntry));
		}
		else
		{
			logError("Could not find/open auto-load profile %s (%s)",
				theValue.c_str(),
				aProfileEntry.path.c_str());
		}
	}
}


static void addParentCallback(
	const std::string& theSection,
	const std::string& theName,
	const std::string& theValue,
	void* theLoadList)
{
	DBG_ASSERT(theSection.empty());
	if( !theLoadList || theValue.empty() )
		return;

	std::vector<int>* aLoadPriorityList = (std::vector<int>*)(theLoadList);

	if( condense(theName) == "PARENTPROFILE" || condense(theName) == "PARENT" )
	{
		const std::string& aProfileName = extractProfileName(theValue);
		ProfileEntry aProfileEntry = profileNameToEntry(aProfileName);
		if( !profileExists(aProfileEntry) )
		{// File not found - but maybe referencing a resource base file?
			const std::string& aCmpName = condense(aProfileName);
			for(int i = 0; i < ARRAYSIZE(kResTemplateBase); ++i)
			{
				if( condense(kResTemplateBase[i].fileName) == aCmpName )
				{
					generateResourceProfile(kResTemplateBase[i]);
					aProfileEntry = profileNameToEntry(aProfileName);
					sNewBaseProfileIdx = getOrAddProfileIdx(aProfileEntry);
					break;
				}
			}
		}
		if( !profileExists(aProfileEntry) )
		{// File still not found - maybe referencing a resource default file?
			const std::string& aCmpName = condense(aProfileName);
			for(int i = 0; i < ARRAYSIZE(kResTemplateDefault); ++i)
			{
				if( condense(kResTemplateDefault[i].fileName) == aCmpName )
				{
					generateResourceProfile(kResTemplateDefault[i]);
					aProfileEntry = profileNameToEntry(aProfileName);
					sNewBaseProfileIdx = getOrAddProfileIdx(aProfileEntry);
					break;
				}
			}
		}
		if( profileExists(aProfileEntry) )
		{
			const int aParentProfileIdx = getOrAddProfileIdx(aProfileEntry);
			// Don't add Core as parent if specified (it's added automatically)
			if( aParentProfileIdx == 0 )
				return;
			// Don't add entries already added (or can get infinite loop)!
			if( std::find(aLoadPriorityList->begin(), aLoadPriorityList->end(),
					aParentProfileIdx) != aLoadPriorityList->end() )
				return;
			aLoadPriorityList->push_back(aParentProfileIdx);
		}
		else
		{
			logError("Could not find/open '%s' Profile's parent: '%s' (%s)",
				sKnownProfiles[*(aLoadPriorityList->begin())].name.c_str(),
				theValue.c_str(), aProfileEntry.path.c_str());
		}
	}
}


static void generateProfileLoadPriorityList(int theProfileListIdx)
{
	DBG_ASSERT(size_t(theProfileListIdx) < sProfilesCanLoad.size());
	std::vector<int>& aList = sProfilesCanLoad[theProfileListIdx];
	if( aList.empty() )
		return;

	// Should only have the main file as first priority at this point
	DBG_ASSERT(aList.size() == 1);
	DBG_ASSERT(size_t(aList[0]) < sKnownProfiles.size());

	// Parse main profile and add parent, parent of parent, etc.
	// NOTE: aList.size() can grow during this, so must be checked each loop
	for(size_t i = 0; i < aList.size(); ++i)
	{
		parseINI(
			addParentCallback,
			sKnownProfiles[aList[i]].path,
			eParseMode_Header,
			&aList);
	}

	// Finally add core .ini as lowest-priority settings
	aList.push_back(0);
}


static void parseProfilesCanLoad()
{
	sKnownProfiles.clear();
	sProfilesCanLoad.clear();
	sAutoProfileIdx = 0;

	// Initially core .ini is only profile known, with others added
	// via parsing core (and other profiles for checking for parents)
	ProfileEntry aCoreProfile = profileNameToEntry(kCoreProfileName);
	if( !profileExists(aCoreProfile) )
	{
		logFatalError("Could not find %s (%s)",
			kCoreProfileName, aCoreProfile.path.c_str());
		return;
	}

	// Add Core as first known profile (profile 0)
	getOrAddProfileIdx(aCoreProfile);
	
	// Get list of load-able profiles and auto-load profile from core
	// Profile '0' reserved for auto-load profile if specified by name
	sProfilesCanLoad.resize(1);
	parseINI(
		getProfileListCallback,
		aCoreProfile.path,
		eParseMode_Header);
}


static void readBaseGameSettingsCallback(
	const std::string& theSection,
	const std::string& theName,
	const std::string& theValue,
	void* theAppInfo)
{
	if( !theAppInfo || theValue.empty() )
		return;

	BaseGameSettings* aSettings = (BaseGameSettings*)(theAppInfo);
	const std::string& aSect = condense(kBaseGameSettingsSection);
	if( condense(theSection) == aSect )
	{
		if( condense(theName) == condense(kAutoLaunchAppKey) )
			aSettings->autoLaunch.path = theValue;
		if( condense(theName) == condense(kAutoLaunchAppParamsKey) )
			aSettings->autoLaunch.params = theValue;
		if( condense(theName) == condense(kXInputFixKey) )
		{
			std::string aStr = theValue;
			aSettings->xInputFix.shouldUse = !theValue.empty();
			// Comma separated - bitwidth, path, exeName, launcherName, exeName
			// "= Notified" will end with aBitWidth == 0, skipping the rest
			if( const int aBitWidth = intFromString(breakOffNextItem(aStr)) )
			{
				aSettings->xInputFix.userWants = true;
				aSettings->xInputFix.use64BitVersion = (aBitWidth == 64);
				aSettings->xInputFix.dirPath = breakOffNextItem(aStr);
				aSettings->xInputFix.exeName = breakOffNextItem(aStr);
				aSettings->xInputFix.launcherName = breakOffNextItem(aStr);
				aSettings->xInputFix.gameName = breakOffNextItem(aStr);
			}
		}
	}
}


static BaseGameSettings getBaseGameSettings(const ProfileEntry& theProfile)
{
	BaseGameSettings aSettings;
	parseINI(
		readBaseGameSettingsCallback,
		theProfile.path,
		eParseMode_Sections,
		&aSettings);
	return aSettings;
}


static void writeBaseGameSettingsChanges(
	ProfileEntry& theProfile,
	const BaseGameSettings& theDefaultSettings,
	const BaseGameSettings& theCustomSettings)
{
	if( !theCustomSettings.autoLaunch.path.empty() ||
		!theDefaultSettings.autoLaunch.path.empty() )
	{
		setPropertyInINI(
			theProfile.path,
			kBaseGameSettingsSection, kAutoLaunchAppKey,
			theCustomSettings.autoLaunch.path);
	}
	if( !theCustomSettings.autoLaunch.params.empty() ||
		!theDefaultSettings.autoLaunch.params.empty() )
	{
		setPropertyInINI(
			theProfile.path,
			kBaseGameSettingsSection, kAutoLaunchAppParamsKey,
			theCustomSettings.autoLaunch.params);
	}
	if( theCustomSettings.xInputFix.shouldUse ||
		theDefaultSettings.xInputFix.shouldUse )
	{
		std::string aStr;
		if( theCustomSettings.xInputFix.dirPath.empty() ||
			(theDefaultSettings.xInputFix.userWants &&
			 !theCustomSettings.xInputFix.userWants) )
		{// Don't bother the user any more
			aStr = "Notified";
		}
		else
		{
			aStr = toString(
				theCustomSettings.xInputFix.use64BitVersion ? 64 : 32);
			aStr += ", \"" + theCustomSettings.xInputFix.dirPath + "\"";
			if( !theCustomSettings.xInputFix.exeName.empty() )
				aStr += ", \"" + theCustomSettings.xInputFix.exeName + "\"";
		}
		setPropertyInINI(
			theProfile.path,
			kBaseGameSettingsSection, kXInputFixKey,
			aStr);
	}
}


static EResult handleXInputFixFlow(
	HWND parentWindow,
	const std::string& promptStr,
	const std::string& dialogTitle,
	std::string& dirPath,
	std::string& exeName,
	bool& use64BitVersion)
{
	EResult result = Dialogs::richTextPrompt(
		parentWindow,
		promptStr,
		dialogTitle,
		"Apply Fix Now", "Skip", "More Info");

	if( result != eResult_Cancel )
	{
		if( result == eResult_Ok )
		{
			result = Dialogs::applyXInputFix(parentWindow,
				dirPath, exeName, use64BitVersion);
		}

		// If clicked More Info on original prompt (eResult_Retry),
		// or cancelled out of apply prompt, show detailed dialog
		if( result != eResult_Ok )
		{
			result = Dialogs::showXInputFixDetails(parentWindow,
				dirPath, exeName, use64BitVersion);
		}
	}

	if( result == eResult_Cancel )
	{
		Dialogs::showNotice(parentWindow,
			"If you need to apply the fix later, you can do so via "
			"the [Help] -> [Double Input Fix] menu option",
			"Double Input fix not applied!");
	}

	return result;
}


static void promptForAutoXInputFix(BaseGameSettings& theSettings)
{
	std::string aPromptStr = "{\\rtf1\\ansi ";
	aPromptStr += theSettings.xInputFix.gameName.empty()
		? std::string("This game")
		: "{\\b\\i " + toRTF(theSettings.xInputFix.gameName) + "}";
	aPromptStr +=
		" has a known \"double input\" gamepad issue. "
		"Apply a one-time fix now?\\par\n\\par\n"
		"You will be asked for the location of the game client program";
	if( !theSettings.xInputFix.exeName.empty() )
		aPromptStr +=
			" ({\\b " + toRTF(theSettings.xInputFix.exeName) + "})";
	aPromptStr +=
		" for this. {\\i Note that it might {\\b not} be in the same folder "
		"as the patcher/launcher";
	if( !theSettings.xInputFix.exeName.empty() )
		aPromptStr +=
			" (" + toRTF(theSettings.xInputFix.launcherName) + ")";
	aPromptStr += "!}}";

	// Use autoLaunch.path as base for relative path, if were given one
	if( theSettings.xInputFix.dirPath[0] == '.' )
	{// Relative path - set to empty or use launcher path as base
		if( !theSettings.autoLaunch.path.empty() )
		{
			theSettings.xInputFix.dirPath = toAbsolutePath(
				getFileDir(
					toAbsolutePath(theSettings.autoLaunch.path),
					true) +
				theSettings.xInputFix.dirPath);
		}
		else
		{
			theSettings.xInputFix.dirPath.clear();
		}
	}

	EResult aResult = handleXInputFixFlow(
		NULL,
		aPromptStr,
		"\"Double Input\" Fix Needed",
		theSettings.xInputFix.dirPath,
		theSettings.xInputFix.exeName,
		theSettings.xInputFix.use64BitVersion);

	theSettings.xInputFix.shouldUse = true;
	theSettings.xInputFix.userWants = aResult == eResult_Ok;
}


static void setAutoLoadProfile(int theProfilesCanLoadIdx)
{
	if( theProfilesCanLoadIdx == sAutoProfileIdx )
		return;

	DBG_ASSERT(!sKnownProfiles.empty());

	if( theProfilesCanLoadIdx > 0 )
	{
		setPropertyInINI(
			sKnownProfiles[0].path,
			"", kAutoLoadProfileKey,
			toString(theProfilesCanLoadIdx));
	}
	else
	{
		setPropertyInINI(
			sKnownProfiles[0].path,
			"", kAutoLoadProfileKey, "");
	}
}


#ifndef _DEBUG
static void readVersionCallback(
	const std::string& theSection,
	const std::string& theName,
	const std::string& theValue,
	void* theVersion)
{
	if( !theVersion || theValue.empty() )
		return;

	int* aVersion = (int*)(theVersion);
	if( condense(theName) == condense(kAutoGenVersionKey) )
		*aVersion = intFromString(theValue);
}
#endif


static void checkForOutdatedFileVersion(ProfileEntry& theFile)
{
	const ResourceProfile* theMatchingResource = NULL;
	bool matchingResourceIsCore = false;
	bool matchingResourceIsBase = false;
	if( theFile.name == kResTemplateCore.fileName )
	{
		theMatchingResource = &kResTemplateCore;
		matchingResourceIsCore = true;
	}
	if( !theMatchingResource )
	{
		for(int i = 0; i < ARRAYSIZE(kResTemplateBase); ++i)
		{
			if( theFile.name == kResTemplateBase[i].fileName )
			{
				theMatchingResource = &kResTemplateBase[i];
				matchingResourceIsBase = true;
				break;
			}
		}
	}
	if( !theMatchingResource )
	{
		for(int i = 0; i < ARRAYSIZE(kResTemplateDefault); ++i)
		{
			if( theFile.name == kResTemplateDefault[i].fileName )
			{
				theMatchingResource = &kResTemplateDefault[i];
				break;
			}
		}
	}
	// Only replace custom files in Debug builds, and only for first loaded
	#ifdef _DEBUG
	if( !theMatchingResource && sLoadedProfileName.empty() )
	{
		for(int i = 0; i < ARRAYSIZE(kResTemplateCustom); ++i)
		{
			if( theFile.name == kResTemplateCustom[i].fileName )
			{
				theMatchingResource = &kResTemplateCustom[i];
				break;
			}
		}
	}
	#endif
	if( !theMatchingResource )
		return;

	// In Debug builds, always (silently) regenerate all generated files
	// every time so always reflect any changes made to resource versions.
	EResult aResult = eResult_Yes;
	#ifndef _DEBUG
	// Check for version number stored in the file
	int aFileVersion = 0;
	parseINI(
		readVersionCallback,
		theFile.path,
		eParseMode_Header,
		&aFileVersion);

	// If version number not specified (or set to 0), ignore it
	if( !aFileVersion )
		return;
	// If file version number >= expected, no change needed
	if( aFileVersion >= theMatchingResource->version )
		return;
	// File is outdated - prompt to replace it!
	aResult = Dialogs::yesNoPrompt(NULL, strFormat(
			"File '%s' was auto-generated by a previous version of this "
			"software. Would you like to replace it with an updated version?\n\n"
			"Any changes made to it since it was generated%swill be lost!",
			getFileName(theFile.path).c_str(),
			matchingResourceIsCore ? " (besides the profile list) " :
			matchingResourceIsBase ? " (besides auto-launch app path) " : " "),
			"Update outdated generated file", true);
	#endif
	if( aResult == eResult_Yes )
	{// Update the generated file to new version
		BaseGameSettings aCustomSettings;
		if( matchingResourceIsBase )
			aCustomSettings = getBaseGameSettings(theFile);
		generateResourceProfile(*theMatchingResource);
		if( matchingResourceIsCore )
		{// Restore known profile list & auto-load setting to regenerated Core
			int autoProfileIdxTmp = 0;
			swap(autoProfileIdxTmp, sAutoProfileIdx);
			setAutoLoadProfile(autoProfileIdxTmp);
			swap(autoProfileIdxTmp, sAutoProfileIdx);
			int aProfID = 1;
			for(int i = 1, end = intSize(sProfilesCanLoad.size());
				i < end; ++i)
			{
				if( !sProfilesCanLoad[i].empty() )
				{
					setPropertyInINI(
						theFile.path, "",
						std::string(kProfileKeyPrefix) + toString(aProfID++),
						sKnownProfiles[sProfilesCanLoad[i][0]].name);
				}
			}
		}
		else if( matchingResourceIsBase )
		{// Restore base game setting changes to regenerated Base file
			const BaseGameSettings& aDefaultSettings =
				getBaseGameSettings(theFile);

			if( !aCustomSettings.xInputFix.shouldUse &&
				aDefaultSettings.xInputFix.shouldUse )
			{// New generated profile now suggests an XInput fix for this game
				aCustomSettings.xInputFix = aDefaultSettings.xInputFix;
				promptForAutoXInputFix(aCustomSettings);
			}

			writeBaseGameSettingsChanges(
				theFile, aDefaultSettings, aCustomSettings);
		}
	}
	else if( aResult == eResult_No )
	{
		// Update the file's version number so won't ask again
		setPropertyInINI(theFile.path,
			"", kAutoGenVersionKey,
			toString(theMatchingResource->version));
	}
	// else if( aResult == eResult_Cancel )
	// Ignore this time since are in-game already - ask again next time!
}


static void userEditProfile(int theProfilesCanLoadIdx, bool firstProfile)
{
	// Generate list of files to possibly edit
	DBG_ASSERT(size_t(theProfilesCanLoadIdx) < sProfilesCanLoad.size());
	const std::vector<int>& aList = sProfilesCanLoad[theProfilesCanLoadIdx];
	DBG_ASSERT(!aList.empty());

	std::vector<std::string> aFileList;
	for(std::vector<int>::const_reverse_iterator itr = aList.rbegin();
		itr != aList.rend(); ++itr)
	{
		DBG_ASSERT(size_t(*itr) < sKnownProfiles.size());
		checkForOutdatedFileVersion(sKnownProfiles[*itr]);
		aFileList.push_back(sKnownProfiles[*itr].path);
	}

	Dialogs::profileEdit(aFileList, firstProfile);
}


static void logPropVarDependency(VarPropDependency theDep, bool init)
{
	if( !init )
	{
		// Just push on to the list and it will be sorted in later
		sVarPropDepList.push_back(theDep);
		return;
	}

	// TODO - Check for existing entry and abort if it is there,
	// otherwise insert into found position
}


static std::string varTagToString(
	const std::string& theVarContents,
	const std::string& theTagStr,
	const size_t theFirstOperatorPos)
{
	std::string result = theVarContents;
	// Replace quoted string with un-trimmed contents
	if( result.size() >= 2 &&
		((result[0] == '"' && result[result.size()-1] == '"') ||
		 (result[0] == '\'' && result[result.size()-1] == '\'')) )
	{
		result = result.substr(1, result.size()-2);
	}

	DBG_ASSERT(theFirstOperatorPos < theTagStr.size());
	size_t aPos = theFirstOperatorPos;
	// Figure out what operator we're dealing with (some use 2 chars)
	u8 anOpC = theTagStr[aPos++];
	const char* aNextDel = "?}";
	switch(anOpC)
	{
	case '}':
		return result;
	case '?':
		aNextDel = ":}";
		break;
	case '~':
		anOpC = '!';
		// fall through
	case '!':
		// Ignore extra '=' for '!=' or '~='
		if( theTagStr[aPos] == '=' )
			++aPos;
		break;
	case '<':
		if( theTagStr[aPos] == '>' )
		{// Treat <> as alternate form of '!'
			anOpC = '!';
			++aPos;
		}
		else if( theTagStr[aPos] == '=' )
		{// Use '[' to mean less-than-or-equal (internally only)
			anOpC = '[';
			++aPos;
		}
		break;
	case '>':
		if( theTagStr[aPos] == '=' )
		{// Use ']' to mean less-than-or-equal (internally only)
			anOpC = ']';
			++aPos;
		}
		break;
	case '=':
		// Ignore extra '='
		if( theTagStr[aPos] == '=' )
			++aPos;
		break;
	case '+': case '-': case '*': case '/':
		aNextDel = "}+*/?!~<>="; // to warn of multi-operator use (except -)
		break;
	default:
		DBG_ASSERT(false && "Unhandled operator character");
	}

	// Get first parameter for operator
	const std::string& aParam = fetchNextItem(theTagStr, aPos, aNextDel);

	// Have all we need for arithmetic operators now
	if( anOpC == '+' || anOpC == '-' || anOpC == '*' || anOpC == '/' )
	{
		if( theTagStr[aPos] != '}' )
		{
			logError("Unexpected %c found in '%s'. "
				"Only one operator is allowed per ${} block! "
				"Use nested ${} blocks for more options.",
				theTagStr[aPos], theTagStr.c_str());
		}
		double aVarNum = doubleFromString(theVarContents);
		double aParamNum = doubleFromStringStrict(aParam);
		if( _isnan(aParamNum) )
		{
			logError("Expected a number instead of '%s' for arithmetic "
				"operator '%c' in '%s'. "
				"Note only one operator is allowed per ${} block!",
				aParam.c_str(), anOpC, theTagStr.c_str());
			aParamNum = 0;
		}
		switch(anOpC)
		{
		case '+': result = toString(aVarNum + aParamNum); break;
		case '-': result = toString(aVarNum - aParamNum); break;
		case '*': result = toString(aVarNum * aParamNum); break;
		case '/':
			if( aParamNum == 0 )
			{
				logError("Division by 0 detected in '%s'!",
					theTagStr.c_str());
				aParamNum = 1.0;
			}
			result = toString(aVarNum / aParamNum);
			break;
		}
		return result;
	}

	// Math done, should only be comparison or ? operator now
	bool isTrue = false;
	switch(anOpC)
	{
	case '<':
		isTrue = doubleFromString(result) < doubleFromString(aParam);
		break;
	case '[':
		isTrue = doubleFromString(result) <= doubleFromString(aParam);
		break;
	case '>':
		isTrue = doubleFromString(result) > doubleFromString(aParam);
		break;
	case ']':
		isTrue = doubleFromString(result) >= doubleFromString(aParam);
	case '=': case '!':
		{
			const double da = doubleFromStringStrict(result);
			const double db = doubleFromStringStrict(aParam);
			if( !_isnan(da) && !_isnan(db) )
				isTrue = da == db;
			else
				isTrue = condense(result) == condense(aParam);
			if( anOpC == '!' )
				isTrue = !isTrue;
		}
		break;
	case '?':
		isTrue = boolFromString(result);
		break;
	default:
		DBG_ASSERT(false && "Unhandled conditional operator");
		break;
	}

	// What to do with compare result depends on first and second operator
	char anOpC2 = theTagStr[aPos++];
	if( anOpC2 == '}' )
	{
		if( anOpC == '?' ) // ${Var ? resultIfTrue}
			result = isTrue ? aParam : result;
		else // ${Var <> ..}
			result = isTrue ? "true" : "false";
		return result;
	}

	DBG_ASSERT(anOpC2 == '?');
	
	// Get return result for 'true' (and check for 'else')
	const std::string& aTrueResult = fetchNextItem(theTagStr, aPos, ":}");
	if( isTrue )
	{
		result = aTrueResult;
		return result;
	}

	// If has 'else' section, return it, otherwise return base var value
	if( theTagStr[aPos++] == ':' )
		result = fetchNextItem(theTagStr, aPos, "}");

	return result;
}


static void expandPropertyVars(int theSectionID, int thePropID, bool init)
{
	PropertyMap& theSection = sSectionsMap.vals()[theSectionID];
	Property& theProp = theSection.vals()[thePropID];
	if( !theProp.str.empty() || theProp.pattern.empty() )
		return;

	std::pair<std::string::size_type, std::string::size_type> aTagCoords =
		findStringTag(theProp.pattern, 0, "${", '}');

	if( aTagCoords.first == std::string::npos )
	{// No variables referenced - set str and clear pattern
		swap(theProp.str, theProp.pattern);
		return;
	}

	VarPropDependency aDep;
	aDep.sectID = theSectionID;
	aDep.propID = thePropID;
	PropertyMap& theVarsMap = sSectionsMap.vals()[kVarsSectionIdx];
	DBG_ASSERT(sSectionsMap.keys()[kVarsSectionIdx] == kVariablesSectionName);

	theProp.str = "\b"; // to detect circular reference from recursion
	std::string aStr = theProp.pattern;
	do {
		// Extract variable name from tag
		size_t aVarOpPos = aTagCoords.first + 2;
		const std::string& aVarName =
			fetchNextItem(aStr, aVarOpPos, "}+-*/?!~<>=");
		DBG_ASSERT(aVarOpPos < aTagCoords.first + aTagCoords.second);
		std::string aRepStr;
		if( aVarName.empty() )
		{
			logError("Missing variable name in property "
				"[%s] / %s = %s!",
				sSectionsMap.keys()[theSectionID].c_str(),
				theSection.keys()[thePropID].c_str(),
				aStr.c_str());
		}
		else
		{
			const int aVarID = theVarsMap.findIndex(aVarName);
			if( aVarID >= theVarsMap.size() )
			{
				logError("Variable name '%s' not found in property "
					"[%s] / %s = %s!",
					aVarName.c_str(),
					sSectionsMap.keys()[theSectionID].c_str(),
					theSection.keys()[thePropID].c_str(),
					aStr.c_str());
			}
			else
			{
				Property& aVarProp =  theVarsMap.vals()[aVarID];
				if( aVarProp.str == "\b" )
				{
					logError("Variable '%s' references self!",
						aVarName.c_str());
				}
				else
				{
					aDep.varID = aVarID;
					logPropVarDependency(aDep, init);
					if( aVarProp.str.empty() && !aVarProp.pattern.empty() )
						expandPropertyVars(kVarsSectionIdx, aVarID, init);

					aRepStr = varTagToString(aVarProp.str, aStr, aVarOpPos);
				}
			}
		}
		aStr = aStr.replace(aTagCoords.first, aTagCoords.second, aRepStr);
		aTagCoords = findStringTag(aStr, 0, "${", '}');
	} while( aTagCoords.first != std::string::npos );

	theProp.str = aStr;
}


static void readProfileCallback(
	const std::string& theSection,
	const std::string& theName,
	const std::string& theValue,
	void*)
{
	PropertyMap& aSection = sSectionsMap.findOrAdd(theSection);
	Property& aProperty = aSection.findOrAdd(theName);
	aProperty.pattern = theValue;
	aProperty.str.clear();
}


static void loadProfile(int theProfilesCanLoadIdx)
{
	sSectionsMap.clear();
	// Make sure "variables" section is always section 0
	sSectionsMap.setValue(kVariablesSectionName, PropertyMap());
	sVarPropDepList.clear();

	DBG_ASSERT(size_t(theProfilesCanLoadIdx) < sProfilesCanLoad.size());
	const std::vector<int>& aList = sProfilesCanLoad[theProfilesCanLoadIdx];
	if( aList.empty() )
		return;

	// Now load each .ini's values 1-by-1 in reverse order.
	// Any setting in later files overrides previous setting,
	// which is why we load them in reverse of priority order
	for(std::vector<int>::const_reverse_iterator itr = aList.rbegin();
		itr != aList.rend(); ++itr)
	{
		DBG_ASSERT(size_t(*itr) < sKnownProfiles.size());
		checkForOutdatedFileVersion(sKnownProfiles[*itr]);
		parseINI(
			readProfileCallback,
			sKnownProfiles[*itr].path,
			eParseMode_Sections);
	}
	sSectionsMap.trim();

	// Process variable expansion for all properties
	for(int aSectionID = 0; aSectionID < sSectionsMap.size(); ++aSectionID)
	{
		PropertyMap& aSection = sSectionsMap.vals()[aSectionID];
		for(int aPropID = 0; aPropID < aSection.size(); ++aPropID)
			expandPropertyVars(aSectionID, aPropID, true);
	}

	// Sort and remove duplicate entries in variable dependency list
	std::sort(sVarPropDepList.begin(), sVarPropDepList.end());
	sVarPropDepList.erase(
		std::unique(sVarPropDepList.begin(), sVarPropDepList.end()),
		sVarPropDepList.end());

	// Now that have loaded a profile, only need to remember the main
	// profile's name and can forget gathered data about other profiles
	sLoadedProfileName = sKnownProfiles[aList[0]].name;
	sKnownProfiles.clear();
	sProfilesCanLoad.clear();
	sAutoProfileIdx = 0;
	sNewBaseProfileIdx = -1;
}


//-----------------------------------------------------------------------------
// Global Functions
//-----------------------------------------------------------------------------

void loadCore()
{
	// Should only be run once at app startup, otherwise core will be
	// loaded alongside normal ::load()
	DBG_ASSERT(sSectionsMap.empty());

	ProfileEntry aCoreProfile = profileNameToEntry(kCoreProfileName);
	if( !profileExists(aCoreProfile) )
	{// Core .ini file not found!
		// Assume this means first run, which means show license agreement
		if( Dialogs::showLicenseAgreement() == eResult_Declined )
		{// Declined license agreement - just exit
			gShutdown = true;
		}
		else
		{// Generate Core.ini which will prevent future license agreement
			generateResourceProfile(kResTemplateCore);
			if( !profileExists(aCoreProfile) )
			{
				logFatalError("Unable to find/write %s (%s)",
					kCoreProfileName, aCoreProfile.path.c_str());
			}
		}
	}
	if( hadFatalError() || gShutdown )
		return;

	parseINI(
		readProfileCallback,
		aCoreProfile.path,
		eParseMode_Sections);
}


void load()
{
	parseProfilesCanLoad();
	if( hadFatalError() || gShutdown )
		return;

	// Make sure sAutoProfileIdx is a valid (even if empty) index
	if( size_t(sAutoProfileIdx) >= sProfilesCanLoad.size() ||
		sProfilesCanLoad[sAutoProfileIdx].empty() )
	{
		if( sAutoProfileIdx > 0 )
		{
			logError(
				"AutoLoadProfile = %d but no profile #%d found!",
				sAutoProfileIdx, sAutoProfileIdx);
		}
		sAutoProfileIdx = 0;
	}

	// If already loaded a profile, override sAutoProfileIdx with it
	if( !sLoadedProfileName.empty() )
	{
		const int aProfileIdx =
			getOrAddProfileIdx(profileNameToEntry(sLoadedProfileName));
		if( aProfileIdx >= 0 )
		{
			sAutoProfileIdx = -1;
			for(int i = 0, end = intSize(sProfilesCanLoad.size());
				i < end; ++i)
			{
				if( !sProfilesCanLoad[i].empty() &&
					sProfilesCanLoad[i][0] == aProfileIdx )
				{
					sAutoProfileIdx = i;
					break;
				}
			}
			if( sAutoProfileIdx == -1 )
			{
				sProfilesCanLoad.push_back(std::vector<int>());
				sProfilesCanLoad.back().push_back(aProfileIdx);
				sAutoProfileIdx = intSize(sProfilesCanLoad.size())-1;
			}
		}
	}

	// Fill out rest of the sProfilesCanLoad vectors
	for(int i = 0, end = intSize(sProfilesCanLoad.size()); i < end; ++i)
		generateProfileLoadPriorityList(i);

	// See if need to query user for profile to load
	if( sProfilesCanLoad[sAutoProfileIdx].empty() )
		queryUserForProfile();
	else
		loadProfile(sAutoProfileIdx);
}


bool queryUserForProfile()
{
	saveChangesToFile();
	int aLastCreatedProfileIdx = -1;
retryQuery:

	if( sKnownProfiles.empty() )
	{
		parseProfilesCanLoad();
		for(int i = 0, end = intSize(sProfilesCanLoad.size()); i < end; ++i)
			generateProfileLoadPriorityList(i);
	}
	if( hadFatalError() )
		return false;

	// Create lists needed for dialog
	enum EType
	{
		eType_CopyFile,			// index into sKnownProfiles
		eType_CopyResCustom,	// index into kResTemplateCustom
		eType_ParentResBase,	// index into kResTemplateBase
		eType_ParentResDefault,	// index into kResTemplateDefault
		eType_ParentFile,		// index into sKnownProfiles
	};
	std::vector<std::string> aLoadableProfileNames;
	std::vector<int> aLoadableProfileIndexes;
	std::vector<std::string> aTemplateProfileNames;
	std::vector<int> aTemplateProfileIndex;
	std::vector<EType> aTemplateProfileType;
	const std::string kCopyFilePrefix = "Copy \"";
	const std::string kParentPrefix = "Customize \"";

	for(int i = 0, end = intSize(sProfilesCanLoad.size()); i < end; ++i)
	{
		if( !sProfilesCanLoad[i].empty() )
		{
			const std::string& aName =
				sKnownProfiles[sProfilesCanLoad[i][0]].name;
			aLoadableProfileNames.push_back(aName);
			aLoadableProfileIndexes.push_back(i);
			aTemplateProfileNames.push_back(
				kCopyFilePrefix + aName + '"');
			aTemplateProfileIndex.push_back(
				sProfilesCanLoad[i][0]);
			aTemplateProfileType.push_back(eType_CopyFile);
		}
	}

	const bool needFirstProfile = aLoadableProfileNames.empty();
	for(int i = 0; i < ARRAYSIZE(kResTemplateCustom); ++i)
	{
		if( needFirstProfile )
		{
			aLoadableProfileNames.push_back(kResTemplateCustom[i].dispName);
			aLoadableProfileIndexes.push_back(i);
		}
		aTemplateProfileNames.push_back(
			kCopyFilePrefix + kResTemplateCustom[i].dispName + '"');
		aTemplateProfileIndex.push_back(i);
		aTemplateProfileType.push_back(eType_CopyResCustom);
	}

	for(int i = 0, end = intSize(sProfilesCanLoad.size()); i < end; ++i)
	{
		aTemplateProfileNames.push_back(
			kParentPrefix + sKnownProfiles[i].name + '"');
		aTemplateProfileIndex.push_back(i);
		aTemplateProfileType.push_back(eType_ParentFile);
	}

	for(int i = 0; i < ARRAYSIZE(kResTemplateBase); ++i)
	{
		// Only add ones that don't already exist in sKnownProfiles
		bool alreadyExists = false;
		const ProfileEntry& aTestEntry =
			profileNameToEntry(kResTemplateBase[i].fileName);
		if( profileExists(aTestEntry) )
		{
			for(int j = 0, end = intSize(sKnownProfiles.size()); j < end; ++j)
			{
				if( isSamePath(sKnownProfiles[j].path, aTestEntry.path) )
				{
					alreadyExists = true;
					break;
				}
			}
		}
		if( alreadyExists )
			continue;
		aTemplateProfileNames.push_back(
			kParentPrefix + kResTemplateBase[i].dispName + '"');
		aTemplateProfileIndex.push_back(i);
		aTemplateProfileType.push_back(eType_ParentResBase);
	}

	for(int i = 0; i < ARRAYSIZE(kResTemplateDefault); ++i)
	{
		bool alreadyExists = false;
		const ProfileEntry& aTestEntry =
			profileNameToEntry(kResTemplateDefault[i].fileName);
		if( profileExists(aTestEntry) )
		{
			for(int j = 0, end = intSize(sKnownProfiles.size()); j < end; ++j)
			{
				if( isSamePath(sKnownProfiles[j].path, aTestEntry.path) )
				{
					alreadyExists = true;
					break;
				}
			}
		}
		if( alreadyExists )
			continue;
		aTemplateProfileNames.push_back(
			kParentPrefix + kResTemplateDefault[i].dispName + '"');
		aTemplateProfileIndex.push_back(i);
		aTemplateProfileType.push_back(eType_ParentResDefault);
	}

	// Use Dialog to ask the user what they want to do
	int aDefaultSelectedIdx = -1;
	if( !sLoadedProfileName.empty() )
	{
		for(int i = 0, end = intSize(aLoadableProfileNames.size());
			i < end; ++i)
		{
			if( aLoadableProfileNames[i] == sLoadedProfileName )
				aDefaultSelectedIdx = i;
		}
	}
	if( aLastCreatedProfileIdx >= 0 )
		aDefaultSelectedIdx = aLastCreatedProfileIdx;
	Dialogs::ProfileSelectResult aDialogResult = Dialogs::profileSelect(
		aLoadableProfileNames,
		aTemplateProfileNames,
		aDefaultSelectedIdx,
		sAutoProfileIdx >= 0 &&
		sAutoProfileIdx < intSize(sProfilesCanLoad.size()) &&
		!sProfilesCanLoad[sAutoProfileIdx].empty(),
		needFirstProfile);

	if( aDialogResult.cancelled )
	{// User declined to select anything
		// If have no profile loaded already, quit app entirely
		if( sLoadedProfileName.empty() )
			gShutdown = true;
		return false;
	}

	// For first profile, if no name given then use built-in name
	// NOTE: This only works out because set the first entries of
	// aTemplateProfile's to match aLoadableProfile's which both
	// match the entries in kResTemplateCustom. So need to change
	// this if rearrange the order of any of these above!
	if( needFirstProfile && aDialogResult.newName.empty() )
		aDialogResult.newName =
			kResTemplateCustom[aDialogResult.selectedIndex].fileName;

	if( aDialogResult.newName.empty() )
	{// User must have requested to load or edit an existing profile
		DBG_ASSERT(size_t(aDialogResult.selectedIndex) <
			aLoadableProfileNames.size());
		const int aProfileCanLoadIdx =
			aLoadableProfileIndexes[aDialogResult.selectedIndex];
		setAutoLoadProfile(
			aDialogResult.autoLoadRequested ? aProfileCanLoadIdx : 0);
		if( aDialogResult.autoLoadRequested )
			sAutoProfileIdx = aProfileCanLoadIdx;
		if( aDialogResult.editProfileRequested )
		{
			userEditProfile(aProfileCanLoadIdx, false);
			goto retryQuery;
		}
		loadProfile(aProfileCanLoadIdx);
		return true;
	}

	// User must have requested creating a new profile
	const std::string& aNewName = extractProfileName(aDialogResult.newName);
	ProfileEntry aNewEntry = profileNameToEntry(aNewName);
	int aSrcIdx = aDialogResult.selectedIndex;
	DBG_ASSERT(size_t(aSrcIdx) < aTemplateProfileIndex.size());

	if( profileExists(aNewEntry) )
	{// File already exists
		if( isSamePath(aNewEntry.path, sKnownProfiles[0].path) )
		{
			Dialogs::showError(NULL,
				"Can not create custom Profile with the name 'Core'!");
			goto retryQuery;
		}
		int duplicateLoadProfileIdx = -1;
		for(int i = 0, end = intSize(sProfilesCanLoad.size()); i < end; ++i)
		{
			const ProfileEntry& aKnownProfile =
				sKnownProfiles[sProfilesCanLoad[i][0]];
			if( !sProfilesCanLoad[i].empty() &&
				isSamePath(aKnownProfile.path, aNewEntry.path) )
			{
				duplicateLoadProfileIdx = i;
				break;
			}
		}
		if( duplicateLoadProfileIdx >= 0 )
		{
			if( Dialogs::yesNoPrompt(NULL, strFormat(
					"Profile '%s' already exists. Overwrite?",
						aNewName.c_str()),
					"Overwrite existing Profile") != eResult_Yes )
			{
				goto retryQuery;
			}
			sProfilesCanLoad[duplicateLoadProfileIdx].clear();
		}
		else
		{
			Dialogs::showError(NULL, strFormat(
				"File '%s' already exists and can't be overwritten "
				"because it is not listed in the profile list in '%s'. "
				"This may indicate it is profile's parent file.",
				getFileName(aNewEntry.path).c_str(), kCoreProfileName));
			goto retryQuery;
		}
	}

	DBG_ASSERT(size_t(aDialogResult.selectedIndex) <
		aTemplateProfileType.size());
	EType aProfileType = aTemplateProfileType[aDialogResult.selectedIndex];
	if( aProfileType == eType_ParentResDefault ||
		aProfileType == eType_CopyResCustom )
	{// Do not allow Base profile names for a new profile of these types
		// This is to prevent possibly having self as grandparent
		const std::string& aCompName = condense(aNewName);
		for(int i = 0; i < ARRAYSIZE(kResTemplateBase); ++i)
		{
			if( aCompName == condense(kResTemplateBase[i].fileName) )
			{
				Dialogs::showError(NULL,
					"Selected Profile name not valid (reserved)!");
				goto retryQuery;
			}
		}
	}

	if( aProfileType == eType_CopyResCustom )
	{// Do not allow Default profile names for a new profile of these types
		// This is to prevent possibly having self as a parent
		const std::string& aCompName = condense(aNewName);
		for(int i = 0; i < ARRAYSIZE(kResTemplateDefault); ++i)
		{
			if( aCompName == condense(kResTemplateDefault[i].fileName) )
			{
				Dialogs::showError(NULL,
					"Selected Profile name not valid (reserved)!");
				goto retryQuery;
			}
		}
	}

	// Find slot in sProfilesCanLoad to add profile to
	int aProfileCanLoadIdx = intSize(sProfilesCanLoad.size());
	for(int i = 1; i < aProfileCanLoadIdx; ++i)
	{
		if( sProfilesCanLoad[i].empty() )
		{
			aProfileCanLoadIdx = i;
			break;
		}
	}
	if( aProfileCanLoadIdx == intSize(sProfilesCanLoad.size()) )
		sProfilesCanLoad.push_back(std::vector<int>());

	switch(aProfileType)
	{
	case eType_CopyFile:
		{// Create copy of source file
			const int aKnownProfileIdx = aTemplateProfileIndex[aSrcIdx];
			DBG_ASSERT(size_t(aKnownProfileIdx) < sKnownProfiles.size());
			const ProfileEntry& aSrcEntry = sKnownProfiles[aKnownProfileIdx];
			// Don't actually do anything if source and dest are the same file
			if( !isSamePath(aNewEntry.path, aSrcEntry.path) )
			{
				CopyFile(
					widen(aSrcEntry.path).c_str(),
					widen(aNewEntry.path).c_str(),
					FALSE);
			}
		}
		break;
	case eType_CopyResCustom:
		{// Generate resource profile but with new file name
			const int aResTemplateIdx = aTemplateProfileIndex[aSrcIdx];
			DBG_ASSERT(aResTemplateIdx >= 0);
			DBG_ASSERT(aResTemplateIdx < ARRAYSIZE(kResTemplateCustom));
			ResourceProfile aResProfile = kResTemplateCustom[aResTemplateIdx];
			aResProfile.fileName = aNewName.c_str();
			generateResourceProfile(aResProfile);
		}
		break;
	case eType_ParentResBase:
	case eType_ParentResDefault:
		{// Generate resource profile to act as parent
			const int aResBaseIdx = aTemplateProfileIndex[aSrcIdx];
			const char* aProfileName = null;
			if( aProfileType == eType_ParentResDefault )
			{
				DBG_ASSERT(aResBaseIdx < ARRAYSIZE(kResTemplateDefault));
				generateResourceProfile(kResTemplateDefault[aResBaseIdx]);
				aProfileName = kResTemplateDefault[aResBaseIdx].fileName;
			}
			else
			{
				DBG_ASSERT(aResBaseIdx < ARRAYSIZE(kResTemplateBase));
				generateResourceProfile(kResTemplateBase[aResBaseIdx]);
				aProfileName = kResTemplateBase[aResBaseIdx].fileName;
			}
			sNewBaseProfileIdx = -1;
			sNewBaseProfileIdx = getOrAddProfileIdx(
				profileNameToEntry(aProfileName));
			if( sNewBaseProfileIdx < 0 )
				break;
			// Treat as _ParentFile type now that resource exists as a file
			aTemplateProfileNames.push_back("");
			aTemplateProfileIndex.push_back(sNewBaseProfileIdx);
			aTemplateProfileType.push_back(eType_ParentFile);
			aSrcIdx = intSize(aTemplateProfileType.size()) - 1;
			aNewEntry = profileNameToEntry(aNewName);
		}
		// fall through
	case eType_ParentFile:
		{// Create new file that sets source file as its parent profile
			const int aKnownProfileIdx = aTemplateProfileIndex[aSrcIdx];
			DBG_ASSERT(size_t(aKnownProfileIdx) < sKnownProfiles.size());
			const ProfileEntry& aSrcEntry = sKnownProfiles[aKnownProfileIdx];
			// Make sure parent and new file are not the same file
			if( isSamePath(aSrcEntry.path, aNewEntry.path) )
			{
				Dialogs::showError(NULL,
					"Selected Profile name matches parent profile name!");
				goto retryQuery;
			}
			std::ofstream aFile(
				widen(aNewEntry.path).c_str(),
				std::ios::out | std::ios::trunc);
			if( aFile.is_open() )
			{
				if( aKnownProfileIdx > 0 )
				{// Don't need to specify if Core is the parent
					aFile << "ParentProfile = ";
					aFile << aSrcEntry.name << std::endl << std::endl;
				}
				aFile.close();
			}
			else
			{
				Dialogs::showError(NULL,
					strFormat("Unable to write Profile data to file %s\n",
						aNewEntry.path.c_str()));
				goto retryQuery;
			}
		}
		break;
	}

	if( !profileExists(aNewEntry) )
	{
		Dialogs::showError(NULL, strFormat(
			"Failure creating new Profile '%s' (%s)!",
			aNewEntry.name.c_str(), aNewEntry.path.c_str()));
		goto retryQuery;
	}

	setPropertyInINI(
		sKnownProfiles[0].path, "",
		std::string(kProfileKeyPrefix) + toString(aProfileCanLoadIdx),
		aNewEntry.name);
	sProfilesCanLoad[aProfileCanLoadIdx].push_back(
		getOrAddProfileIdx(aNewEntry));
	generateProfileLoadPriorityList(aProfileCanLoadIdx);
	sAutoProfileIdx = -1;
	setAutoLoadProfile(
		aDialogResult.autoLoadRequested ? aProfileCanLoadIdx : 0);
	if( aDialogResult.autoLoadRequested )
		sAutoProfileIdx = aProfileCanLoadIdx;
	aLastCreatedProfileIdx = aProfileCanLoadIdx;

	// Extra prompts for first time create a "base" profile, which represents
	// the shared default values for all profiles for a particular game, and
	// thus need to set some of these default but game-specific settings
	if( sNewBaseProfileIdx >= 0 )
	{
		// Load defaults values from generated file
		const BaseGameSettings& aDefaultSettings =
			getBaseGameSettings(sKnownProfiles[sNewBaseProfileIdx]);
		BaseGameSettings aSettings = aDefaultSettings;

		// Prompt user for auto-launch configuration
		Dialogs::targetAppPath(
			aSettings.autoLaunch.path,
			aSettings.autoLaunch.params);

		// Check if related game has a known issue of improper controller
		// support that can't be disabled, and if so suggest the fix
		if( aDefaultSettings.xInputFix.shouldUse )
			promptForAutoXInputFix(aSettings);

		writeBaseGameSettingsChanges(
			sKnownProfiles[sNewBaseProfileIdx],
			aDefaultSettings,
			aSettings);
	}
	sNewBaseProfileIdx = -1;

	if( needFirstProfile )
	{
		if( Dialogs::yesNoPrompt(NULL,
				"Would you like to edit this Profile now to match your in-game "
				"Key Binds and other settings?",
				"Edit new profile") == eResult_Yes )
		{
			userEditProfile(aLastCreatedProfileIdx, true);
		}
		else
		{
			loadProfile(aProfileCanLoadIdx);
			return true;
		}
	}

	// loop and query again to actually load the new profile
	goto retryQuery;
}


void queryUserForXInputFixPref(HWND theParentWindow)
{
	std::string anXInputFixValue =
		getStr(kBaseGameSettingsSection, kXInputFixKey);
	const int aBitWidth = intFromString(breakOffNextItem(anXInputFixValue));
	bool use64BitVersion = (aBitWidth == 64);
	std::string aDirPath, anExeName;
	if( aBitWidth )
	{
		aDirPath = breakOffNextItem(anXInputFixValue);
		if( !aDirPath.empty() )
			aDirPath = toAbsolutePath(aDirPath);
		anExeName = breakOffNextItem(anXInputFixValue);
	}

	EResult aResult = Dialogs::showXInputFixDetails(
		theParentWindow,
		aDirPath, anExeName, use64BitVersion);

	if( aResult == eResult_Ok && !aDirPath.empty() )
	{
		anXInputFixValue = toString(use64BitVersion ? 64 : 32);
		anXInputFixValue += ", \"" + aDirPath + "\"";
		if( !anExeName.empty() )
			anXInputFixValue += ", \"" + anExeName + "\"";
		setStr(kBaseGameSettingsSection, kXInputFixKey, anXInputFixValue);
	}
	else if( aResult == eResult_Declined )
	{
		setStr(kBaseGameSettingsSection, kXInputFixKey, "Removed");
	}
	saveChangesToFile();
}


void confirmXInputFix(HWND theParentWindow)
{
	std::string anXInputFixValue =
		getStr(kBaseGameSettingsSection, kXInputFixKey);
	if( anXInputFixValue.empty() )
		return;

	const int aBitWidth = intFromString(breakOffNextItem(anXInputFixValue));
	if( !aBitWidth )
		return;

	bool use64BitVersion = (aBitWidth == 64);
	std::string aDirPath, anExeName;
	if( aBitWidth )
	{
		aDirPath = breakOffNextItem(anXInputFixValue);
		if( !aDirPath.empty() )
			aDirPath = toAbsolutePath(aDirPath);
		anExeName = breakOffNextItem(anXInputFixValue);
	}

	const std::string& aFixFilePath =
		toAbsolutePath(aDirPath, true) + "xinput1_3.dll";
	if( isValidFilePath(aFixFilePath) )
		return;

	const std::string& aPromptStr =
		"{\\rtf1\\ansi "
		"The \"double input\" fix that was previously applied ("
		"{\\b " + toRTF(aFixFilePath) + "}) can no longer be found. "
		"Would you like to apply it again now?}";

	EResult aResult = handleXInputFixFlow(
		theParentWindow,
		aPromptStr,
		"\"Double Input\" Fix Missing!",
		aDirPath,
		anExeName,
		use64BitVersion);

	if( aResult == eResult_Ok && !aDirPath.empty() )
	{
		anXInputFixValue = toString(use64BitVersion ? 64 : 32);
		anXInputFixValue += ", \"" + aDirPath + "\"";
		if( !anExeName.empty() )
			anXInputFixValue += ", \"" + anExeName + "\"";
		setStr(kBaseGameSettingsSection, kXInputFixKey, anXInputFixValue);
	}
	else
	{
		setStr(kBaseGameSettingsSection, kXInputFixKey, "Notified");
	}
	saveChangesToFile();
}


std::string getStr(
	const std::string& theSection,
	const std::string& thePropertyName,
	const std::string& theDefaultValue)
{
	if( const PropertyMap* aSection = getSection(theSection) )
	{
		if( const Property* aProp = aSection->find(thePropertyName) )
		{
			if( !aProp->str.empty() )
				return aProp->str;
		}
	}

	return theDefaultValue;
}


int getInt(
	const std::string& theSection,
	const std::string& theName,
	int theDefaultValue)
{
	const std::string& aStr = getStr(theSection, theName);
	if( !aStr.empty() )
		return intFromString(aStr);
	return theDefaultValue;
}


bool getBool(
	const std::string& theSection,
	const std::string& theName,
	bool theDefaultValue)
{
	const std::string& aStr = getStr(theSection, theName);
	if( !aStr.empty() )
		return boolFromString(aStr);
	return theDefaultValue;
}


double getFloat(
	const std::string& theSection,
	const std::string& theName,
	double theDefaultValue)
{
	const std::string& aStr = getStr(theSection, theName);
	if( !aStr.empty() )
		return doubleFromString(aStr);
	return theDefaultValue;
}


const PropertyMap* getSection(const std::string& theSectionName)
{
	return sSectionsMap.find(theSectionName);
}


const PropertyMap& getSectionProperties(const std::string& theSectionName)
{
	static const PropertyMap kEmptyMap = PropertyMap();
	if( const PropertyMap* aSection = getSection(theSectionName) )
		return *aSection;
	return kEmptyMap;
}


const SectionsMap& allSections()
{
	return sSectionsMap;
}


void setStr(
	const std::string& theSection,
	const std::string& thePropertyName,
	const std::string& theValue,
	bool saveToFile)
{
	// Add/change main properties map
	const int aSectionID = sSectionsMap.findOrAddIndex(theSection);
	PropertyMap& aSection = sSectionsMap.vals()[aSectionID];
	const int aPropID = aSection.findOrAddIndex(thePropertyName);
	Property& aProp = aSection.vals()[aPropID];
	if( (aProp.pattern.empty() && aProp.str == theValue) ||
		aProp.pattern == theValue )
		return;
	aProp.str.clear();
	aProp.pattern = theValue;

	// Apply variable expansion to new/changed property
	expandPropertyVars(aSectionID, aPropID, false);

	// Log in changed properties map as well
	sChangedSectionsMap.findOrAdd(theSection)
		.setValue(thePropertyName, aProp);
	
	// TODO - if( aSectionID == kVarsSectionIdx ) propogate variable to others
	// Make sure sChangedSectionsMap includes properties changed by variable
	// adjustment (but not unsavedChangesList)

	if( saveToFile )
	{// Log as change to save to file
		for(int i = 0, end = intSize(sUnsavedChangesList.size()); i < end; ++i)
		{
			if( sUnsavedChangesList[i].section == theSection &&
				sUnsavedChangesList[i].name == thePropertyName )
			{
				sUnsavedChangesList[i].val = theValue;
				return;
			}
		}

		UnsavedProperty aNewProperty;
		aNewProperty.section = theSection;
		aNewProperty.name = thePropertyName;
		aNewProperty.val = theValue;
		sUnsavedChangesList.push_back(aNewProperty);
	}
}


void setNewStr(
	const std::string& theSection,
	const std::string& thePropertyName,
	const std::string& theValue)
{
	if( getStr(theSection, thePropertyName) == "" )
		setStr(theSection, thePropertyName, theValue);
}


const SectionsMap& changedSections()
{
	return sChangedSectionsMap;
}


void clearChangedSections()
{
	sChangedSectionsMap.clear();
}


void saveChangesToFile()
{
	if( sUnsavedChangesList.empty() || sLoadedProfileName.empty() )
		return;
	const std::string& aFilePath = profileNameToFilePath(sLoadedProfileName);
	for(int i = 0, end = intSize(sUnsavedChangesList.size()); i < end; ++i)
	{
		setPropertyInINI(
			aFilePath,
			sUnsavedChangesList[i].section,
			sUnsavedChangesList[i].name,
			sUnsavedChangesList[i].val);
	}
	sUnsavedChangesList.clear();
}

} // Profile
