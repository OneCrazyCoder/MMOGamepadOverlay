//-----------------------------------------------------------------------------
//	Originally written by Taron Millet, except where otherwise noted
//-----------------------------------------------------------------------------

#include "Profile.h"

#include "Dialogs.h"
#include "Resources/resource.h"

#include <fstream>

namespace Profile
{

//-----------------------------------------------------------------------------
// Const Data
//-----------------------------------------------------------------------------

enum {
kINIFileBufferSize = 256, // How many characters to process at a time from .ini
};

struct ResourceProfile
{
	const char* dispName;
	const char* fileName;
	const WORD resID;
	const u8 version;
};

struct ProfileEntry
{
	std::string name;
	std::string path;
};

struct AutoLaunchAppInfo
{
	std::string path;
	std::string params;
};

const char* kProfileFileNamePrefix = "MMOGO_";
const char* kProfileFileNameSuffix = ".ini";
const char* kProfileKeyPrefix = "Profile";
const char* kCoreProfileName = "MMOGO_Core.ini";
const char* kAutoLaunchAppKeySection = "System";
const char* kAutoLaunchAppKey = "AutoLaunchApp";
const char* kAutoLaunchAppParamsKey = "AutoLaunchAppParams";
const char* kAutoLoadProfileKey = "AutoLoadProfile";
const char* kAutoGenVersionKey = "AutoGeneratedVersion";
const std::string kEndOfLine = "\r\n";

const ResourceProfile kResTemplateCore =
	{	"Core",			"Core",			IDR_TEXT_INI_CORE,		1	};

const ResourceProfile kResTemplateBase[] =
{//		name			fileName		resID					vers
	{	"M&M Base",		"MnM Base",		IDR_TEXT_INI_BASE_MNM,	1	},
	{	"P99 Base",		"P99 Base",		IDR_TEXT_INI_BASE_P99,	1	},
	{	"PQ Base",		"PQ Base",		IDR_TEXT_INI_BASE_PQ,	1	},
};

const ResourceProfile kResTemplateDefault[] =
{//		name			fileName		resID					vers
	{	"M&M Default",	"MnM Default",	IDR_TEXT_INI_DEF_MNM,	1	},
	{	"P99 Default",	"P99 Default",	IDR_TEXT_INI_DEF_P99,	1	},
	{	"PQ Default",	"PQ Default",	IDR_TEXT_INI_DEF_PQ,	1	},
};

const ResourceProfile kResTemplateCustom[] =
{//		name			fileName		resID					vers
#ifdef _DEBUG
	{	"M&M Default",	"MnM Custom",	IDR_TEXT_INI_CUST_MNM,	0	},
	{	"P99 Default",	"P99 Custom",	IDR_TEXT_INI_CUST_P99,	0	},
	{	"PQ Default",	"PQ Custom",	IDR_TEXT_INI_CUST_PQ,	0	},
	{	"M&M Taron",	"MnM Taron",	IDR_TEXT_INI_TARON_MNM,	0	},
	{	"P99 Taron",	"P99 Taron",	IDR_TEXT_INI_TARON_P99,	0	},
	{	"PQ Taron",		"PQ Taron",		IDR_TEXT_INI_TARON_PQ,	0	},
#else
	{	"M&M Default",	"MnM",			IDR_TEXT_INI_CUST_MNM,	0	},
	{	"P99 Default",	"P99",			IDR_TEXT_INI_CUST_P99,	0	},
	{	"PQ Default",	"PQ",			IDR_TEXT_INI_CUST_PQ,	0	},
	{	"M&M Taron",	"MnM",			IDR_TEXT_INI_TARON_MNM,	0	},
	{	"P99 Taron",	"P99",			IDR_TEXT_INI_TARON_P99,	0	},
	{	"PQ Taron",		"PQ",			IDR_TEXT_INI_TARON_PQ,	0	},
#endif
};

enum EParseMode
{
	eParseMode_Header,
	eParseMode_Sections,
};

typedef void (*ParseINICallback)(
	const std::string& theKey,
	const std::string& theValue,
	void* theUserData);

struct ProfileProperty
{
	std::string name;
	std::string val;

	ProfileProperty() {}
	ProfileProperty(const std::string& name, const std::string& val) :
		name(name), val(val) {}
};
typedef StringToValueMap<ProfileProperty> PropertyMap;


//-----------------------------------------------------------------------------
// Static Variables
//-----------------------------------------------------------------------------

static PropertyMap sPropertyMap;
static std::vector<ProfileEntry> sKnownProfiles;
static std::vector< std::vector<int> > sProfilesCanLoad;
static std::string sLoadedProfileName;
static int sAutoProfileIdx = 0;
static int sNewBaseProfileIdx = -1;


//-----------------------------------------------------------------------------
// Local Functions
//-----------------------------------------------------------------------------

static const std::string& iniFolderPath()
{
	static std::string sFolderPath;
	if( sFolderPath.empty() )
	{
		// Just use our application folder (for now)
		TCHAR aPath[_MAX_PATH];
		GetModuleFileName(NULL, aPath, _MAX_PATH);
		sFolderPath = getFileDir(narrow(aPath), true);
		_wchdir(widen(sFolderPath).c_str());

		// Make sure it actually exists
		// (obviously it has to, but leaving this here for possibly
		// later changing the .ini folder to AppData or something)
		size_t aCurPos = 0;
		for (;;)
		{
			size_t aSlashPos = sFolderPath.find_first_of("\\/", aCurPos);
			if (aSlashPos == -1)
			{
				_wmkdir(widen(sFolderPath).c_str());
				break;
			}

			aCurPos = aSlashPos+1;

			std::string aCurPath = sFolderPath.substr(0, aSlashPos);
			_wmkdir(widen(aCurPath).c_str());
		}
	}

	return sFolderPath;
}


static void clearOutOldProfiles()
{
	const std::string& aFolderPath = iniFolderPath();

	// Cut-off date: July 12th, 2024
	SYSTEMTIME aCutoffDate = { 2024, 7, -1, 12, 0, 0, 0, 0 };
	FILETIME aCutoffFileTime;
	SystemTimeToFileTime(&aCutoffDate, &aCutoffFileTime);

	std::string aSearchPattern = iniFolderPath() + kProfileFileNamePrefix;
	aSearchPattern += "*";
	aSearchPattern += kProfileFileNameSuffix;

	WIN32_FIND_DATAW aFindFileData;
	HANDLE hFind = FindFirstFile(
		widen(aSearchPattern).c_str(),
		&aFindFileData);
	if( hFind == INVALID_HANDLE_VALUE )
		return;

	// Backup and delete any profile files created before cutoff date
	do {
		if( !(aFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
		{
			FILETIME creationTime = aFindFileData.ftCreationTime;
			if( CompareFileTime(&creationTime, &aCutoffFileTime) < 0 )
			{
				const std::wstring& aWPath =
					widen(aFolderPath) + aFindFileData.cFileName;
				const std::wstring& aNewWPath = aWPath + L".bak";
				if( CopyFile(aWPath.c_str(), aNewWPath.c_str(), FALSE) )
					DeleteFile(aWPath.c_str());
			}
		}
	} while (FindNextFile(hFind, &aFindFileData) != 0);
}


static std::string extractProfileName(const std::string& theString)
{
	std::string result = removeExtension(getFileName(theString));
	const std::string& prefix = upper(kProfileFileNamePrefix);
	if( upper(result).compare(0, prefix.length(), upper(prefix)) == 0 )
		result = result.substr(prefix.length());
	return replaceChar(result, '_', ' ');
}


static std::string profileNameToFilePath(const std::string& theName)
{
	DBG_ASSERT(theName == extractProfileName(theName));
	std::string result = iniFolderPath();
	result += kProfileFileNamePrefix;
	result += replaceChar(theName, ' ', '_');
	result += kProfileFileNameSuffix;
	return result;
}


static bool profileExists(const std::string& theFilePath)
{
	const DWORD aFileAttributes = GetFileAttributesW(
		widen(theFilePath).c_str());

	return
		aFileAttributes != INVALID_FILE_ATTRIBUTES &&
		!(aFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}


static bool profileExists(const ProfileEntry& theEntry)
{
	return profileExists(theEntry.path);
}


static DWORD uniqueFileId(const std::string& theFilePath)
{
	DWORD result = 0; // 0 == invalid file
	if( theFilePath.empty() )
		return result;

	const std::wstring& aFilePathW = widen(theFilePath);
	const DWORD aFileAttributes = GetFileAttributes(aFilePathW.c_str());
	if( aFileAttributes == INVALID_FILE_ATTRIBUTES ||
		(aFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
		return result;

	HANDLE hFile = CreateFile(aFilePathW.c_str(),
		GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if( hFile != INVALID_HANDLE_VALUE )
	{
		BY_HANDLE_FILE_INFORMATION aFileInfo;
		if( GetFileInformationByHandle(hFile, &aFileInfo) )
		{
			result = aFileInfo.dwVolumeSerialNumber ^
				((aFileInfo.nFileIndexHigh << 16) | aFileInfo.nFileIndexLow) ^
				aFileInfo.ftCreationTime.dwHighDateTime ^
				aFileInfo.ftCreationTime.dwLowDateTime;
		}
		CloseHandle(hFile);
	}

	return result;
}


static bool operator==(const ProfileEntry& lhs, const ProfileEntry& rhs)
{
	return
		lhs.path == rhs.path ||
		uniqueFileId(lhs.path) == uniqueFileId(rhs.path);
}


static bool operator!=(const ProfileEntry& lhs, const ProfileEntry& rhs)
{
	return !(lhs == rhs);
}


static ProfileEntry profileNameToEntry(const std::string& theProfileName)
{
	ProfileEntry anEntry;
	anEntry.name = extractProfileName(theProfileName);
	anEntry.path = profileNameToFilePath(anEntry.name);
	return anEntry;
}


static int getOrAddProfileIdx(const ProfileEntry& theProfileEntry)
{
	// A map would be faster, but requires a separate Map structure
	// to ensure stable indexes (or using pointers instead), and
	// there's unlikely to be a whole lot of these anyway.
	for(int i = 0; i < sKnownProfiles.size(); ++i)
	{
		if( sKnownProfiles[i] == theProfileEntry )
			return i;
	}

	sKnownProfiles.push_back(theProfileEntry);
	return int(sKnownProfiles.size()) - 1;
}


static void parseINI(
	ParseINICallback theCallbackFunc,
	const std::string& theFilePath,
	EParseMode theParseMode,
	void* theUserData = NULL)
{
	std::ifstream aFile(widen(theFilePath).c_str(), std::ios::binary);
	if( !aFile.is_open() )
	{
		logFatalError("Could not open file %s", theFilePath.c_str());
		return;
	}

	// Prepare input buffer
	// +1 on size is to accommodate an extra newline character when
	// reach end of file
	char aBuffer[kINIFileBufferSize+1];
	std::streamsize aBufferSize = kINIFileBufferSize;
	std::string aNewSection;
	std::string aSection;
	std::string aKey;
	std::string aValue;

	enum
	{
		ePIState_Whitespace,
		ePIState_Section,
		ePIState_Key,
		ePIState_Value,
		ePIState_Comment,
	} aState = ePIState_Whitespace;

	while(aFile.good())
	{
		// Read next chunk from file
		aFile.read(aBuffer, aBufferSize);
		if( aFile.eof() || aFile.gcount() < aBufferSize )
		{// Put eol at end of file in case there wasn't one already
			aBufferSize = aFile.gcount() + 1;
			aBuffer[aBufferSize-1] = '\n';
			DBG_ASSERT(aBufferSize <= ARRAYSIZE(aBuffer));
		}
		else if( aFile.bad() )
		{
			logFatalError("Unknown error reading %s", theFilePath.c_str());
			aFile.close();
			return;
		}

		for(int i = 0; i < aBufferSize; ++i)
		{// Step through buffer character-by-character
			const char c = aBuffer[i];
			switch(aState)
			{
			case ePIState_Whitespace:
				// Look for a section, key, or comment
				if( c == '[' )
				{
					if( theParseMode == eParseMode_Header )
					{// Stop parsing once hit [ in this mode
						aFile.close();
						return;
					}
					aState = ePIState_Section;
					aNewSection.clear();
				}
				else if( c == '#' || c == ';' )
				{
					aState = ePIState_Comment;
				}
				else if( !isspace(c) )
				{
					if( theParseMode == eParseMode_Sections &&
						aSection.empty() )
					{// Treat anything before first section as a comment
						aState = ePIState_Comment;
					}
					else
					{
						aState = ePIState_Key;
						aKey = aSection;
						if( !aKey.empty() )
							aKey.push_back('/');
						aKey.push_back(c);
					}
				}
				break;

			case ePIState_Section:
				// Look for end of line after ']' to end section
				switch(c)
				{
				case '\r': case '\n': case '\0':
					aNewSection = trim(aNewSection);
					if( aNewSection.size() > 1 &&
						aNewSection[aNewSection.size()-1] == ']' )
					{
						aNewSection.resize(aNewSection.size()-1);
						aSection.swap(aNewSection);
					}
					aState = ePIState_Whitespace;
					break;
				default:
					aNewSection.push_back(c);
				}
				break;

			case ePIState_Key:
				// Look for '=' to end key
				if( c == '=' )
				{// Switch from parsing key to value
					aKey = trim(aKey);
					aState = ePIState_Value;
					aValue.clear();
				}
				else if( c == '\r' || c == '\n' || c == '\0' )
				{// Abort - invalid key
					aState = ePIState_Whitespace;
				}
				else
				{
					aKey.push_back(c);
				}
				break;

			case ePIState_Value:
				// Look for eol to end value
				if( c == '\r' || c == '\n' || c == '\0' )
				{// Value string complete, time to process it!
					aValue = trim(aValue);
					theCallbackFunc(aKey, aValue, theUserData);
					aState = ePIState_Whitespace;
				}
				else
				{
					aValue.push_back(c);
				}
				break;

			case ePIState_Comment:
				// Look for eol to end comment
				if( c == '\r' || c == '\n' || c == '\0' )
					aState = ePIState_Whitespace;
				break;
			}
		}
	}

	aFile.close();
}


static bool areOnSameVolume(
	const std::string& thePath1,
	const std::string& thePath2)
{
	DWORD aPath1VolumeSerialNumber;
	if(!GetVolumeInformation(widen(getRootDir(thePath1)).c_str(), 0, 0,
							  &aPath1VolumeSerialNumber, 0, 0, 0, 0))
	{
		return false;
	}
	DWORD aPath2VolumeSerialNumber;
	if(!GetVolumeInformation(widen(getRootDir(thePath2)).c_str(), 0, 0,
							  &aPath2VolumeSerialNumber, 0, 0, 0, 0))
	{
		return false;
	}

	return aPath1VolumeSerialNumber == aPath2VolumeSerialNumber;
}


static void setKeyValueInINI(
	const std::string& theFilePath,
	const std::string& theSection,
	const std::string& theKey,
	const std::string& theValue)
{
	// Open source file
	std::ifstream aFile(widen(theFilePath).c_str(), std::ios::binary);
	if( !aFile.is_open() )
	{
		logError("Could not open file %s", theFilePath.c_str());
		return;
	}

	// Create temp output file
	std::string aTmpPath;
	{// Prefer to use temp folder if can, to reduce risk of leaving a mess
		WCHAR aPathBuffer[MAX_PATH];
		DWORD aLen = GetTempPath(MAX_PATH, aPathBuffer);
		if( aLen > 0 && aLen <= MAX_PATH )
			aTmpPath = narrow(aPathBuffer);
	}
	// ReplaceFile() requires both files be on the same drive...
	if( aTmpPath.empty() || !areOnSameVolume(aTmpPath, theFilePath) )
		aTmpPath = getFileDir(theFilePath, true);
	aTmpPath += "~"; aTmpPath += getFileName(theFilePath);
	std::ofstream aTmpFile(
		widen(aTmpPath).c_str(),
		std::ios::binary | std::ios::trunc);
	if( !aTmpFile.is_open() )
	{
		logError("Could not create temp file %s", aTmpPath.c_str());
		aFile.close();
		return;
	}

	// Prepare buffer
	// +1 on size is to accommodate an extra newline character when
	// reach end of file
	char aBuffer[kINIFileBufferSize+1];
	std::streamsize aBufferSize = kINIFileBufferSize;
	std::string aCheckStr;
	const std::string& aCmpSection = condense(theSection);
	const std::string& aCmpKey = condense(theKey);

	enum
	{
		eSKVState_FindSection,
		eSKVState_CheckSection,
		eSKVState_SkipSectionLine,
		eSKVState_FindKey,
		eSKVState_CheckKey,
		eSKVState_SkipKeyLine,
		eSKVState_ValueLine,
		eSKVState_Finished,
	} aState = eSKVState_FindSection;
	if( theSection.empty() )
		aState = eSKVState_FindKey;

	// Parse the INI file to find start and end of segment to replace
	const std::fstream::pos_type kInvalidFilePos = -1;
	std::fstream::pos_type aReplaceStartPos = kInvalidFilePos;
	std::fstream::pos_type aReplaceEndPos = kInvalidFilePos;
	std::fstream::pos_type anEndOfValidSection = kInvalidFilePos;
	std::fstream::pos_type aCurrFilePos = aFile.tellg();
	std::fstream::pos_type aLastNonWhitespace = aCurrFilePos;

	while(aFile.good() && aState != eSKVState_Finished)
	{
		// Read next chunk from file
		aFile.read(aBuffer, aBufferSize);
		if( aFile.eof() || aFile.gcount() < aBufferSize )
		{// Put eol at end of file in case there wasn't one already
			aBufferSize = aFile.gcount() + 1;
			aBuffer[aBufferSize-1] = '\n';
			DBG_ASSERT(aBufferSize <= ARRAYSIZE(aBuffer));
		}
		else if( aFile.bad() )
		{
			logError("Unknown error reading %s", theFilePath.c_str());
			aFile.close();
			return;
		}

		for(int i = 0; i < aBufferSize && aState != eSKVState_Finished; ++i)
		{// Step through buffer character-by-character
			const char c = aBuffer[i];
			if( !isspace(c) )
				aLastNonWhitespace = aCurrFilePos;
			switch(aState)
			{
			case eSKVState_FindSection:
				// Look for a section
				if( c == '[' )
				{
					aState = eSKVState_CheckSection;
					aCheckStr.clear();
				}
				else if( !isspace(c) )
				{
					aState = eSKVState_SkipSectionLine;
				}
				break;

			case eSKVState_CheckSection:
				// Look for endline after ']' to end section
				switch(c)
				{
				case '\r': case '\n': case '\0':
					aState = eSKVState_FindSection;
					aCheckStr = condense(aCheckStr);
					if( aCheckStr.size() > 1 &&
						aCheckStr[aCheckStr.size()-1] == ']' )
					{
						aCheckStr.resize(aCheckStr.size()-1);
						if( aCheckStr == aCmpSection )
							aState = eSKVState_FindKey;
						else if( aCmpSection.empty() )
							aState = eSKVState_Finished;
					}
					break;
				default:
					aCheckStr.push_back(c);
					break;
				}
				break;

			case eSKVState_SkipSectionLine:
				// Look for end of line than resume section search
				if( c == '\r' || c == '\n' || c == '\0' )
					aState = eSKVState_FindSection;
				break;

			case eSKVState_FindKey:
				// Look for start of a key
				if( c == '[' )
				{
					aState = eSKVState_CheckSection;
					aCheckStr.clear();
				}
				else if( c == '#' || c == ';' )
				{
					aState = eSKVState_SkipKeyLine;
				}
				else if( !isspace(c) )
				{
					aState = eSKVState_CheckKey;
					aCheckStr.clear();
					aCheckStr.push_back(c);
				}
				break;

			case eSKVState_CheckKey:
				// Look for '=' to end key
				if( c == '=' )
				{// End of the key - check if this is the one being looked for
					if( condense(aCheckStr) == aCmpKey )
					{// Found starting position to replace with new characters!
						aReplaceStartPos = aCurrFilePos;
						aReplaceStartPos += std::fstream::off_type(1);
						aState = eSKVState_ValueLine;
					}
					else
					{// Not the right key, skip rest of this line
						aState = eSKVState_SkipKeyLine;
					}
				}
				else if( c == '\r' || c == '\n' || c == '\0' )
				{// Abort - invalid key
					aState = eSKVState_FindKey;
				}
				else
				{
					aCheckStr.push_back(c);
				}
				break;

			case eSKVState_SkipKeyLine:
				// Look for end of line then resume key search
				if( c == '\r' || c == '\n' || c == '\0' )
				{
					aState = eSKVState_FindKey;
					anEndOfValidSection = aCurrFilePos;
				}
				break;

			case eSKVState_ValueLine:
				// Look for eol to end section to replace
				if( c == '\r' || c == '\n' || c == '\0' )
				{
					aReplaceEndPos = aCurrFilePos;
					aState = eSKVState_Finished;
				}
				break;
			}
			aCurrFilePos += std::fstream::off_type(1);
		}
	}

	// Clear eof flag
	aFile.clear();

	// Decide what to write and where exactly from info gathered above
	std::string aWriteString;
	if( aReplaceStartPos != kInvalidFilePos )
	{
		// Found the existing key, just write new value
		DBG_ASSERT(aReplaceEndPos != kInvalidFilePos);
		aWriteString = std::string(" ") + trim(theValue);
	}
	else if( anEndOfValidSection != kInvalidFilePos )
	{
		// Found section, write key and value
		aReplaceStartPos = aReplaceEndPos = anEndOfValidSection;
		aWriteString = kEndOfLine + trim(theKey) + " = " + trim(theValue);
	}
	else
	{
		// Found nothing, write section, key, and value
		aReplaceStartPos = aLastNonWhitespace;
		aReplaceStartPos += std::fstream::off_type(1);
		aFile.seekg(0, std::ios::end);
		aReplaceEndPos = aFile.tellg();
		aWriteString = kEndOfLine + kEndOfLine + "[";
		aWriteString += trim(theSection) + "]" + kEndOfLine;
		aWriteString += trim(theKey) + " = " + trim(theValue);
		aWriteString += kEndOfLine;
	}

	// Write aFile 0->aReplaceStartPos to temp file
	aFile.seekg(0, std::ios::beg);
	aCurrFilePos = aFile.tellg();
	while(aCurrFilePos < aReplaceStartPos && aFile.good())
	{
		const std::streamsize aBytesToRead =
			min(kINIFileBufferSize, aReplaceStartPos - aCurrFilePos);
		aFile.read(aBuffer, aBytesToRead);
		aTmpFile.write(aBuffer, aFile.gcount());
		aCurrFilePos += aFile.gcount();
	}

	// Write new data
	aTmpFile << aWriteString;

	// Write aReplaceEndPos->eof to temp file
	aFile.seekg(aReplaceEndPos, std::ios::beg);
	while(aFile.read(aBuffer, kINIFileBufferSize))
		aTmpFile.write(aBuffer, aFile.gcount());
	aTmpFile.write(aBuffer, aFile.gcount());

	// Close both files
	aFile.close();
	aTmpFile.close();

	// Replace original file with new temp file (and delete temp file)
	if( !ReplaceFile(widen(theFilePath).c_str(), widen(aTmpPath).c_str(),
			NULL, REPLACEFILE_IGNORE_MERGE_ERRORS, NULL, NULL) )
	{
		logError("Failed to modify file %s!", theFilePath.c_str());
	}
}


static void generateResourceProfile(const ResourceProfile& theResProfile)
{
	HMODULE hModule = GetModuleHandle(NULL);

	HRSRC hResource = FindResource(
		hModule,
		MAKEINTRESOURCE(theResProfile.resID), L"TEXT");

	if( hResource != NULL )
	{
		HGLOBAL hGlobal = LoadResource(hModule, hResource);

		if( hGlobal != NULL )
		{
			void* aData = LockResource(hGlobal);
			DWORD aSize = SizeofResource(hModule, hResource);

			const std::string& aFilePath =
				profileNameToFilePath(theResProfile.fileName);
			std::ofstream aFile(
				widen(aFilePath).c_str(),
				std::ios::binary | std::ios::trunc);
			if( aFile.is_open() )
			{
				aFile.write(static_cast<char*>(aData), aSize);
				aFile.close();
			}
			else
			{
				logFatalError("Unable to write Profile data to file %s\n",
					aFilePath.c_str());
			}
			FreeResource(hGlobal);

			if( theResProfile.version )
			{
				setKeyValueInINI(aFilePath,
					"", kAutoGenVersionKey,
					toString(theResProfile.version));
			}
		}
	}
}


static void getProfileListCallback(
   const std::string& theKey,
   const std::string& theValue,
   void*)
{
	if( theValue.empty() )
		return;
	const std::string& aProfileNameKey = condense(theKey);
	const std::string& aProfileKeyPrefix = condense(kProfileKeyPrefix);
	if( aProfileNameKey.compare(0,
			aProfileKeyPrefix.length(), aProfileKeyPrefix) == 0 )
	{// Profile name entry
		const int aProfileNum =
			intFromString(aProfileNameKey.substr(aProfileKeyPrefix.length()));
		if( aProfileNum > 0 && !theValue.empty() )
		{
			const ProfileEntry& aProfileEntry = profileNameToEntry(theValue);
			if( profileExists(aProfileEntry) )
			{
				if( aProfileNum >= sProfilesCanLoad.size() )
					sProfilesCanLoad.resize((size_t)aProfileNum + 1);
				sProfilesCanLoad[aProfileNum].push_back(
					getOrAddProfileIdx(aProfileEntry));
			}
			else
			{
				logError("Could not find/open profile '%s' (%s) listed in %s",
					theValue.c_str(),
					aProfileEntry.path.c_str(),
					kCoreProfileName);
			}
		}
	}
	else if( aProfileNameKey == condense(kAutoLoadProfileKey) )
	{// Auto-load profile entry
		if( theValue.empty() )
			return;

		int anAutoProfileNum = intFromString(theValue);
		if( anAutoProfileNum > 0 &&
			toString(anAutoProfileNum).length() == theValue.length() )
		{// Specified by number
			sAutoProfileIdx = anAutoProfileNum;
			return;
		}

		// Specified by name
		const ProfileEntry& aProfileEntry = profileNameToEntry(theValue);
		if( profileExists(aProfileEntry) )
		{
			DBG_ASSERT(!sProfilesCanLoad.empty());
			sProfilesCanLoad[0].push_back(
				getOrAddProfileIdx(aProfileEntry));
		}
		else
		{
			logError("Could not find/open auto-load profile %s (%s)",
				theValue.c_str(),
				aProfileEntry.path.c_str());
		}
	}
}


static void addParentCallback(
   const std::string& theKey,
   const std::string& theValue,
   void* theLoadList)
{
	if( !theLoadList || theValue.empty() )
		return;

	std::vector<int>* aLoadPriorityList = (std::vector<int>*)(theLoadList);

	if( condense(theKey) == "PARENTPROFILE" || condense(theKey) == "PARENT" )
	{
		const std::string& aProfileName = extractProfileName(theValue);
		ProfileEntry aProfileEntry = profileNameToEntry(aProfileName);
		if( !profileExists(aProfileEntry) )
		{// File not found - but maybe referencing a resource base file?
			const std::string& aCmpName = condense(aProfileName);
			for(size_t i = 0; i < ARRAYSIZE(kResTemplateBase); ++i)
			{
				if( condense(kResTemplateBase[i].fileName) == aCmpName )
				{
					generateResourceProfile(kResTemplateBase[i]);
					aProfileEntry = profileNameToEntry(aProfileName);
					sNewBaseProfileIdx = getOrAddProfileIdx(aProfileEntry);
					break;
				}
			}
		}
		if( !profileExists(aProfileEntry) )
		{// File still not found - maybe referencing a resource default file?
			const std::string& aCmpName = condense(aProfileName);
			for(size_t i = 0; i < ARRAYSIZE(kResTemplateDefault); ++i)
			{
				if( condense(kResTemplateDefault[i].fileName) == aCmpName )
				{
					generateResourceProfile(kResTemplateDefault[i]);
					aProfileEntry = profileNameToEntry(aProfileName);
					sNewBaseProfileIdx = getOrAddProfileIdx(aProfileEntry);
					break;
				}
			}
		}
		if( profileExists(aProfileEntry) )
		{
			const int aParentProfileIdx = getOrAddProfileIdx(aProfileEntry);
			// Don't add Core as parent if specified (it's added automatically)
			if( aParentProfileIdx == 0 )
				return;
			// Don't add entries already added (or can get infinite loop)!
			if( std::find(aLoadPriorityList->begin(), aLoadPriorityList->end(),
					aParentProfileIdx) != aLoadPriorityList->end() )
				return;
			aLoadPriorityList->push_back(aParentProfileIdx);
		}
		else
		{
			logError("Could not find/open '%s' Profile's parent: '%s' (%s)",
				sKnownProfiles[*(aLoadPriorityList->begin())].name.c_str(),
				theValue.c_str(), aProfileEntry.path.c_str());
		}
	}
}


static void generateProfileLoadPriorityList(int theProfileListIdx)
{
	DBG_ASSERT(theProfileListIdx >= 0);
	DBG_ASSERT(theProfileListIdx < sProfilesCanLoad.size());
	std::vector<int>& aList = sProfilesCanLoad[theProfileListIdx];
	if( aList.empty() )
		return;

	// Should only have the main file as first priority at this point
	DBG_ASSERT(aList.size() == 1);
	DBG_ASSERT(aList[0] >= 0 && aList[0] < sKnownProfiles.size());

	// Parse main profile and add parent, parent of parent, etc.
	size_t aLoadListSize = 0;
	while(aList.size() > aLoadListSize)
	{
		parseINI(
			addParentCallback,
			sKnownProfiles[aList[aLoadListSize++]].path,
			eParseMode_Header,
			&aList);
	}

	// Finally add core .ini as lowest-priority settings
	aList.push_back(0);
}


static void parseProfilesCanLoad()
{
	sKnownProfiles.clear();
	sProfilesCanLoad.clear();
	sAutoProfileIdx = 0;

	// Initially core .ini is only profile known, with others added
	// via parsing core (and other profiles for checking for parents)
	ProfileEntry aCoreProfile = profileNameToEntry(kCoreProfileName);
	if( !profileExists(aCoreProfile) )
	{
		logFatalError("Could not find %s (%s)",
			kCoreProfileName, aCoreProfile.path.c_str());
		return;
	}

	{// Add Core as first known profile (profile 0)
		int aCoreID = getOrAddProfileIdx(aCoreProfile);
		DBG_ASSERT(aCoreID == 0);
	}

	// Get list of load-able profiles and auto-load profile from core
	// Profile '0' reserved for auto-load profile if specified by name
	sProfilesCanLoad.resize(1);
	parseINI(
		getProfileListCallback,
		aCoreProfile.path,
		eParseMode_Header);
}


static void readAutoLaunchAppCallback(
   const std::string& theKey,
   const std::string& theValue,
   void* theAppInfo)
{
	if( !theAppInfo || theValue.empty() )
		return;

	AutoLaunchAppInfo* anAppInfo = (AutoLaunchAppInfo*)(theAppInfo);
	const std::string& aSect = condense(kAutoLaunchAppKeySection) + "/";
	if( condense(theKey) == aSect + condense(kAutoLaunchAppKey) )
		anAppInfo->path = theValue;
	if( condense(theKey) == aSect + condense(kAutoLaunchAppParamsKey) )
		anAppInfo->params = theValue;
}


static AutoLaunchAppInfo getAutoLaunchAppInfo(const ProfileEntry& theProfile)
{
	AutoLaunchAppInfo anAppInfo;
	parseINI(
		readAutoLaunchAppCallback,
		theProfile.path,
		eParseMode_Sections,
		&anAppInfo);
	return anAppInfo;
}


static void tryAddAutoLaunchApp(int theProfileIdx)
{
	// Load the properties from the profile to get the default params
	AutoLaunchAppInfo anAppInfo =
		getAutoLaunchAppInfo(sKnownProfiles[theProfileIdx]);
	Dialogs::targetAppPath(anAppInfo.path, anAppInfo.params);
	setKeyValueInINI(
		sKnownProfiles[theProfileIdx].path,
		kAutoLaunchAppKeySection, kAutoLaunchAppKey,
		anAppInfo.path);
	setKeyValueInINI(
		sKnownProfiles[theProfileIdx].path,
		kAutoLaunchAppKeySection, kAutoLaunchAppParamsKey,
		anAppInfo.params);
}


static void setAutoLoadProfile(int theProfilesCanLoadIdx)
{
	if( theProfilesCanLoadIdx == sAutoProfileIdx )
		return;

	DBG_ASSERT(!sKnownProfiles.empty());

	if( theProfilesCanLoadIdx > 0 )
	{
		setKeyValueInINI(
			sKnownProfiles[0].path,
			"", kAutoLoadProfileKey,
			toString(theProfilesCanLoadIdx));
	}
	else
	{
		setKeyValueInINI(
			sKnownProfiles[0].path,
			"", kAutoLoadProfileKey, "");
	}
}


static void readVersionCallback(
   const std::string& theKey,
   const std::string& theValue,
   void* theVersion)
{
	if( !theVersion || theValue.empty() )
		return;

	int* aVersion = (int*)(theVersion);
	if( condense(theKey) == condense(kAutoGenVersionKey) )
		*aVersion = intFromString(theValue);
}


static void checkForOutdatedFileVersion(ProfileEntry& theFile)
{
	const ResourceProfile* theMatchingResource = NULL;
	bool matchingResourceIsCore = false;
	bool matchingResourceIsBase = false;
	if( theFile.name == kResTemplateCore.fileName )
	{
		theMatchingResource = &kResTemplateCore;
		matchingResourceIsCore = true;
	}
	if( !theMatchingResource )
	{
		for(size_t i = 0; i < ARRAYSIZE(kResTemplateBase); ++i)
		{
			if( theFile.name == kResTemplateBase[i].fileName )
			{
				theMatchingResource = &kResTemplateBase[i];
				matchingResourceIsBase = true;
				break;
			}
		}
	}
	if( !theMatchingResource )
	{
		for(size_t i = 0; i < ARRAYSIZE(kResTemplateDefault); ++i)
		{
			if( theFile.name == kResTemplateDefault[i].fileName )
			{
				theMatchingResource = &kResTemplateDefault[i];
				break;
			}
		}
	}
	// Only replace custom files in Debug builds
	#ifdef _DEBUG
	if( !theMatchingResource )
	{
		for(size_t i = 0; i < ARRAYSIZE(kResTemplateCustom); ++i)
		{
			if( theFile.name == kResTemplateCustom[i].fileName )
			{
				theMatchingResource = &kResTemplateCustom[i];
				break;
			}
		}
	}
	#endif
	if( !theMatchingResource )
		return;

	// In Debug builds, always (silently) regenerate all generated files
	// every time so always reflect any changes made to resource versions.
	EResult aResult = eResult_Yes;
	#ifndef _DEBUG
	// Check for version number stored in the file
	int aFileVersion = 0;
	parseINI(
		readVersionCallback,
		theFile.path,
		eParseMode_Header,
		&aFileVersion);

	// If version number not specified (or set to 0), ignore it
	if( !aFileVersion )
		return;
	// If file version number >= expected, no change needed
	if( aFileVersion >= theMatchingResource->version )
		return;
	// File is outdated - prompt to replace it!
	aResult = Dialogs::yesNoPrompt(strFormat(
			"File '%s' was auto-generated by a previous version of this "
			"software. Would you like to replace it with an updated version?\n\n"
			"Any changes made to it since it was generated%swill be lost!",
			getFileName(theFile.path).c_str(),
			matchingResourceIsCore ? " (besides the profile list) " :
			matchingResourceIsBase ? " (besides auto-launch app path) " : " "),
			"Update outdated generated file", true);
	#endif
	if( aResult == eResult_Yes )
	{// Update the generated file to new version
		AutoLaunchAppInfo anAppInfo;
		if( matchingResourceIsBase )
			anAppInfo = getAutoLaunchAppInfo(theFile);
		generateResourceProfile(*theMatchingResource);
		if( matchingResourceIsCore )
		{// Restore known profile list & auto-load setting to regenerated Core
			int autoProfileIdxTmp = 0;
			swap(autoProfileIdxTmp, sAutoProfileIdx);
			setAutoLoadProfile(autoProfileIdxTmp);
			swap(autoProfileIdxTmp, sAutoProfileIdx);
			int aProfID = 1;
			for(size_t i = 1; i < sProfilesCanLoad.size(); ++i)
			{
				if( !sProfilesCanLoad[i].empty() )
				{
					setKeyValueInINI(
						theFile.path, "",
						std::string(kProfileKeyPrefix) + toString(aProfID++),
						sKnownProfiles[sProfilesCanLoad[i][0]].name);
				}
			}
		}
		else if( matchingResourceIsBase )
		{// Restore auto-launch app path and params to regenerated Base file
			setKeyValueInINI(
				theFile.path,
				kAutoLaunchAppKeySection, kAutoLaunchAppKey,
				anAppInfo.path);
			setKeyValueInINI(
				theFile.path,
				kAutoLaunchAppKeySection, kAutoLaunchAppParamsKey,
				anAppInfo.params);
		}
	}
	else if( aResult == eResult_No )
	{
		// Update the file's version number so won't ask again
		setKeyValueInINI(theFile.path,
			"", kAutoGenVersionKey,
			toString(theMatchingResource->version));
	}
	// else if( aResult == eResult_Cancel )
	// Ignore this time since are in-game already - ask again next time!
}


static void userEditProfile(int theProfilesCanLoadIdx, bool firstProfile)
{
	// Generate list of files to possibly edit
	DBG_ASSERT(theProfilesCanLoadIdx >= 0);
	DBG_ASSERT(theProfilesCanLoadIdx < sProfilesCanLoad.size());
	const std::vector<int>& aList = sProfilesCanLoad[theProfilesCanLoadIdx];
	DBG_ASSERT(!aList.empty());

	std::vector<std::string> aFileList;
	for(std::vector<int>::const_reverse_iterator itr = aList.rbegin();
		itr != aList.rend(); ++itr)
	{
		DBG_ASSERT(*itr >= 0);
		DBG_ASSERT(*itr < sKnownProfiles.size());
		checkForOutdatedFileVersion(sKnownProfiles[*itr]);
		aFileList.push_back(sKnownProfiles[*itr].path);
	}

	Dialogs::profileEdit(aFileList, firstProfile);
}


static void readProfileCallback(
   const std::string& theKey,
   const std::string& theValue,
   void*)
{
	sPropertyMap.setValue(condense(theKey), ProfileProperty(theKey, theValue));
}


static void loadProfile(int theProfilesCanLoadIdx)
{
	sPropertyMap.clear();
	sPropertyMap.trim();

	DBG_ASSERT(theProfilesCanLoadIdx >= 0);
	DBG_ASSERT(theProfilesCanLoadIdx < sProfilesCanLoad.size());
	const std::vector<int>& aList = sProfilesCanLoad[theProfilesCanLoadIdx];
	if( aList.empty() )
		return;

	// Now load each .ini's values 1-by-1 in reverse order.
	// Any setting in later files overrides previous setting,
	// which is why we load them in reverse of priority order
	for(std::vector<int>::const_reverse_iterator itr = aList.rbegin();
		itr != aList.rend(); ++itr)
	{
		DBG_ASSERT(*itr >= 0);
		DBG_ASSERT(*itr < sKnownProfiles.size());
		checkForOutdatedFileVersion(sKnownProfiles[*itr]);
		parseINI(
			readProfileCallback,
			sKnownProfiles[*itr].path,
			eParseMode_Sections);
	}

	// Now that have loaded a profile, only need to remember the main
	// profile's name and can forget gathered data about other profiles
	sLoadedProfileName = sKnownProfiles[aList[0]].name;
	sKnownProfiles.clear();
	sProfilesCanLoad.clear();
	sAutoProfileIdx = 0;
	sNewBaseProfileIdx = -1;
}


//-----------------------------------------------------------------------------
// Global Functions
//-----------------------------------------------------------------------------

void loadCore()
{
	// Should only be run once at app startup, otherwise core will be
	// loaded alongside normal ::load()
	DBG_ASSERT(sPropertyMap.empty());

	// Don't use any profiles created before the versioning system was added
	clearOutOldProfiles();

	ProfileEntry aCoreProfile = profileNameToEntry(kCoreProfileName);
	if( !profileExists(aCoreProfile) )
	{// Core .ini file not found!
		// Assume this means first run, which means show license agreement
		if( Dialogs::showLicenseAgreement() == eResult_Declined )
		{// Declined license agreement - just exit
			gShutdown = true;
		}
		else
		{// Generate Core.ini which will prevent future license agreement
			generateResourceProfile(kResTemplateCore);
			if( !profileExists(aCoreProfile) )
			{
				logFatalError("Unable to find/write %s (%s)",
					kCoreProfileName, aCoreProfile.path.c_str());
			}
		}
	}
	if( hadFatalError() || gShutdown )
		return;
	
	parseINI(
		readProfileCallback,
		aCoreProfile.path,
		eParseMode_Sections);
}


void load()
{
	parseProfilesCanLoad();
	if( hadFatalError() || gShutdown )
		return;

	// Make sure sAutoProfileIdx is a valid (even if empty) index
	if( sAutoProfileIdx < 0 ||
		sAutoProfileIdx >= sProfilesCanLoad.size() ||
		sProfilesCanLoad[sAutoProfileIdx].empty() )
	{
		if( sAutoProfileIdx > 0 )
		{
			logError(
				"AutoLoadProfile = %d but no profile #%d found!",
				sAutoProfileIdx, sAutoProfileIdx);
		}
		sAutoProfileIdx = 0;
	}

	// If already loaded a profile, override sAutoProfileIdx with it
	if( !sLoadedProfileName.empty() )
	{
		const int aProfileIdx =
			getOrAddProfileIdx(profileNameToEntry(sLoadedProfileName));
		if( aProfileIdx >= 0 )
		{
			sAutoProfileIdx = -1;
			for(size_t i = 0; i < sProfilesCanLoad.size(); ++i)
			{
				if( !sProfilesCanLoad[i].empty() &&
					sProfilesCanLoad[i][0] == aProfileIdx )
				{
					sAutoProfileIdx = int(i);
					break;
				}
			}
			if( sAutoProfileIdx == -1 )
			{
				sProfilesCanLoad.push_back(std::vector<int>());
				sProfilesCanLoad.back().push_back(aProfileIdx);
				sAutoProfileIdx = int(sProfilesCanLoad.size())-1;
			}
		}
	}

	// Fill out rest of the sProfilesCanLoad vectors
	for(int i = 0; i < sProfilesCanLoad.size(); ++i)
		generateProfileLoadPriorityList(i);

	// See if need to query user for profile to load
	if( sProfilesCanLoad[sAutoProfileIdx].empty() )
		queryUserForProfile();
	else
		loadProfile(sAutoProfileIdx);
}


bool queryUserForProfile()
{
	int aLastCreatedProfileIdx = -1;
retryQuery:

	if( sKnownProfiles.empty() )
	{
		parseProfilesCanLoad();
		for(int i = 0; i < sProfilesCanLoad.size(); ++i)
			generateProfileLoadPriorityList(i);
	}
	if( hadFatalError() )
		return false;

	// Create lists needed for dialog
	enum EType
	{
		eType_CopyFile,			// index into sKnownProfiles
		eType_CopyResCustom,	// index into kResTemplateCustom
		eType_ParentResBase,	// index into kResTemplateBase
		eType_ParentResDefault,	// index into kResTemplateDefault
		eType_ParentFile,		// index into sKnownProfiles
	};
	std::vector<std::string> aLoadableProfileNames;
	std::vector<int> aLoadableProfileIndices;
	std::vector<std::string> aTemplateProfileNames;
	std::vector<int> aTemplateProfileIndex;
	std::vector<EType> aTemplateProfileType;
	const std::string kCopyFilePrefix = "Copy \"";
	const std::string kCopyResPrefix = "Copy generated \"";
	const std::string kParentPrefix = "Empty w/ parent \"";

	for(int i = 0; i < sProfilesCanLoad.size(); ++i)
	{
		if( !sProfilesCanLoad[i].empty() )
		{
			const std::string& aName =
				sKnownProfiles[sProfilesCanLoad[i][0]].name;
			aLoadableProfileNames.push_back(aName);
			aLoadableProfileIndices.push_back(i);
			aTemplateProfileNames.push_back(
				kCopyFilePrefix + aName + '"');
			aTemplateProfileIndex.push_back(
				sProfilesCanLoad[i][0]);
			aTemplateProfileType.push_back(eType_CopyFile);
		}
	}

	const bool needFirstProfile = aLoadableProfileNames.empty();
	for(int i = 0; i < ARRAYSIZE(kResTemplateCustom); ++i)
	{
		if( needFirstProfile )
		{
			aLoadableProfileNames.push_back(kResTemplateCustom[i].dispName);
			aLoadableProfileIndices.push_back(i);
		}
		aTemplateProfileNames.push_back(
			kCopyResPrefix + kResTemplateCustom[i].dispName + '"');
		aTemplateProfileIndex.push_back(i);
		aTemplateProfileType.push_back(eType_CopyResCustom);
	}

	for(int i = 0; i < sKnownProfiles.size(); ++i)
	{
		aTemplateProfileNames.push_back(
			kParentPrefix + sKnownProfiles[i].name + '"');
		aTemplateProfileIndex.push_back(i);
		aTemplateProfileType.push_back(eType_ParentFile);
	}

	for(int i = 0; i < ARRAYSIZE(kResTemplateBase); ++i)
	{
		// Only add ones that don't already exist in sKnownProfiles
		bool alreadyExists = false;
		const ProfileEntry& aTestEntry =
			profileNameToEntry(kResTemplateBase[i].fileName);
		if( profileExists(aTestEntry) )
		{
			for(int j = 0; j < sKnownProfiles.size(); ++j)
			{
				if( sKnownProfiles[j] == aTestEntry )
				{
					alreadyExists = true;
					break;
				}
			}
		}
		if( alreadyExists )
			continue;
		aTemplateProfileNames.push_back(
			kParentPrefix + kResTemplateBase[i].dispName + '"');
		aTemplateProfileIndex.push_back(i);
		aTemplateProfileType.push_back(eType_ParentResBase);
	}

	for(int i = 0; i < ARRAYSIZE(kResTemplateDefault); ++i)
	{
		bool alreadyExists = false;
		const ProfileEntry& aTestEntry =
			profileNameToEntry(kResTemplateDefault[i].fileName);
		if( profileExists(aTestEntry) )
		{
			for(int j = 0; j < sKnownProfiles.size(); ++j)
			{
				if( sKnownProfiles[j] == aTestEntry )
				{
					alreadyExists = true;
					break;
				}
			}
		}
		if( alreadyExists )
			continue;
		aTemplateProfileNames.push_back(
			kParentPrefix + kResTemplateDefault[i].dispName + '"');
		aTemplateProfileIndex.push_back(i);
		aTemplateProfileType.push_back(eType_ParentResDefault);
	}

	// Use Dialog to ask the user what they want to do
	int aDefaultSelectedIdx = -1;
	if( !sLoadedProfileName.empty() )
	{
		for(int i = 0; i < aLoadableProfileNames.size(); ++i)
		{
			if( aLoadableProfileNames[i] == sLoadedProfileName )
				aDefaultSelectedIdx = i;
		}
	}
	if( aLastCreatedProfileIdx >= 0 )
		aDefaultSelectedIdx = aLastCreatedProfileIdx;
	Dialogs::ProfileSelectResult aDialogResult = Dialogs::profileSelect(
		aLoadableProfileNames,
		aTemplateProfileNames,
		aDefaultSelectedIdx,
		sAutoProfileIdx >= 0 &&
		sAutoProfileIdx < sProfilesCanLoad.size() &&
		!sProfilesCanLoad[sAutoProfileIdx].empty(),
		needFirstProfile);

	if( aDialogResult.cancelled )
	{// User declined to select anything
		// If have no profile loaded already, quit app entirely
		if( sLoadedProfileName.empty() )
			gShutdown = true;
		return false;
	}

	// For first profile, if no name given then use built-in name
	// NOTE: This only works out because set the first entries of
	// aTemplateProfile's to match aLoadableProfile's which both
	// match the entries in kResTemplateCustom. So need to change
	// this if rearrange the order of any of these above!
	if( needFirstProfile && aDialogResult.newName.empty() )
		aDialogResult.newName =
			kResTemplateCustom[aDialogResult.selectedIndex].fileName;

	if( aDialogResult.newName.empty() )
	{// User must have requested to load or edit an existing profile
		DBG_ASSERT(aDialogResult.selectedIndex < aLoadableProfileNames.size());
		const int aProfileCanLoadIdx =
			aLoadableProfileIndices[aDialogResult.selectedIndex];
		setAutoLoadProfile(
			aDialogResult.autoLoadRequested ? aProfileCanLoadIdx : 0);
		if( aDialogResult.editProfileRequested )
		{
			userEditProfile(aProfileCanLoadIdx, false);
			goto retryQuery;
		}
		loadProfile(aProfileCanLoadIdx);
		return true;
	}

	// User must have requested creating a new profile
	const std::string& aNewName = extractProfileName(aDialogResult.newName);
	ProfileEntry aNewEntry = profileNameToEntry(aNewName);
	size_t aSrcIdx = (unsigned)aDialogResult.selectedIndex;
	DBG_ASSERT(aSrcIdx < aTemplateProfileIndex.size());

	if( profileExists(aNewEntry) )
	{// File already exists
		if( aNewEntry == sKnownProfiles[0] )
		{
			Dialogs::showError(
				"Can not create custom Profile with the name 'Core'!");
			goto retryQuery;
		}
		int duplicateLoadProfileIdx = -1;
		for(int i = 0; i < sProfilesCanLoad.size(); ++i)
		{
			if( !sProfilesCanLoad[i].empty() &&
				sKnownProfiles[sProfilesCanLoad[i][0]] == aNewEntry )
			{
				duplicateLoadProfileIdx = i;
				break;
			}
		}
		if( duplicateLoadProfileIdx >= 0 )
		{
			if( Dialogs::yesNoPrompt(strFormat(
					"Profile '%s' already exists. Overwrite?",
						aNewName.c_str()),
					"Overwrite existing Profile") != eResult_Yes )
			{
				goto retryQuery;
			}
			sProfilesCanLoad[duplicateLoadProfileIdx].clear();
		}
		else
		{
			Dialogs::showError(strFormat(
				"File '%s' already exists and can't be overwritten "
				"because it is not listed in the profile list in '%s'."
				"This may indicate it is profile's parent file.",
				getFileName(aNewEntry.path).c_str(), kCoreProfileName));
			goto retryQuery;
		}
	}

	DBG_ASSERT(aDialogResult.selectedIndex < aTemplateProfileType.size());
	EType aProfileType = aTemplateProfileType[aDialogResult.selectedIndex];
	if( aProfileType == eType_ParentResDefault ||
		aProfileType == eType_CopyResCustom )
	{// Do not allow Base profile names for a new profile of these types
		// This is to prevent possibly having self as grandparent
		const std::string& aCompName = condense(aNewName);
		for(size_t i = 0; i < ARRAYSIZE(kResTemplateBase); ++i)
		{
			if( aCompName == condense(kResTemplateBase[i].fileName) )
			{
				Dialogs::showError(
					"Selected Profile name not valid (reserved)!");
				goto retryQuery;
			}
		}
	}

	if( aProfileType == eType_CopyResCustom )
	{// Do not allow Default profile names for a new profile of these types
		// This is to prevent possibly having self as a parent
		const std::string& aCompName = condense(aNewName);
		for(size_t i = 0; i < ARRAYSIZE(kResTemplateDefault); ++i)
		{
			if( aCompName == condense(kResTemplateDefault[i].fileName) )
			{
				Dialogs::showError(
					"Selected Profile name not valid (reserved)!");
				goto retryQuery;
			}
		}
	}

	// Find slot in sProfilesCanLoad to add profile to
	int aProfileCanLoadIdx = int(sProfilesCanLoad.size());
	for(int i = 1; i < sProfilesCanLoad.size(); ++i)
	{
		if( sProfilesCanLoad[i].empty() )
		{
			aProfileCanLoadIdx = i;
			break;
		}
	}
	if( aProfileCanLoadIdx >= sProfilesCanLoad.size() )
		sProfilesCanLoad.resize(aProfileCanLoadIdx+1);

	switch(aProfileType)
	{
	case eType_CopyFile:
		{// Create copy of source file
			const size_t aKnownProfileIdx = aTemplateProfileIndex[aSrcIdx];
			DBG_ASSERT(aKnownProfileIdx < sKnownProfiles.size());
			const ProfileEntry& aSrcEntry = sKnownProfiles[aKnownProfileIdx];
			// Don't actually do anything if source and dest are the same file
			if( aNewEntry != aSrcEntry )
			{
				CopyFile(
					widen(aSrcEntry.path).c_str(),
					widen(aNewEntry.path).c_str(),
					FALSE);
			}
		}
		break;
	case eType_CopyResCustom:
		{// Generate resource profile but with new file name
			const size_t aResTemplateIdx = aTemplateProfileIndex[aSrcIdx];
			DBG_ASSERT(aResTemplateIdx < ARRAYSIZE(kResTemplateCustom));
			ResourceProfile aResProfile = kResTemplateCustom[aResTemplateIdx];
			aResProfile.fileName = aNewName.c_str();
			generateResourceProfile(aResProfile);
		}
		break;
	case eType_ParentResBase:
	case eType_ParentResDefault:
		{// Generate resource profile to act as parent
			const size_t aResBaseIdx = aTemplateProfileIndex[aSrcIdx];
			const char* aProfileName = null;
			if( aProfileType == eType_ParentResDefault )
			{
				DBG_ASSERT(aResBaseIdx < ARRAYSIZE(kResTemplateDefault));
				generateResourceProfile(kResTemplateDefault[aResBaseIdx]);
				aProfileName = kResTemplateDefault[aResBaseIdx].fileName;
			}
			else
			{
				DBG_ASSERT(aResBaseIdx < ARRAYSIZE(kResTemplateBase));
				generateResourceProfile(kResTemplateBase[aResBaseIdx]);
				aProfileName = kResTemplateBase[aResBaseIdx].fileName;
			}
			sNewBaseProfileIdx = -1;
			sNewBaseProfileIdx = getOrAddProfileIdx(
				profileNameToEntry(aProfileName));
			if( sNewBaseProfileIdx < 0 )
				break;
			// Treat as _ParentFile type now that resource exists as a file
			aTemplateProfileNames.push_back("");
			aTemplateProfileIndex.push_back(sNewBaseProfileIdx);
			aTemplateProfileType.push_back(eType_ParentFile);
			aSrcIdx = aTemplateProfileType.size() - 1;
			aNewEntry = profileNameToEntry(aNewName);
		}
		// fall through
	case eType_ParentFile:
		{// Create new file that sets source file as its parent profile
			const size_t aKnownProfileIdx = aTemplateProfileIndex[aSrcIdx];
			DBG_ASSERT(aKnownProfileIdx < sKnownProfiles.size());
			const ProfileEntry& aSrcEntry = sKnownProfiles[aKnownProfileIdx];
			// Make sure parent and new file are not the same file
			if( aSrcEntry == aNewEntry )
			{
				Dialogs::showError(
					"Selected Profile name matches parent profile name!");
				goto retryQuery;
			}
			std::ofstream aFile(
				widen(aNewEntry.path).c_str(),
				std::ios::out | std::ios::trunc);
			if( aFile.is_open() )
			{
				if( aKnownProfileIdx > 0 )
				{// Don't need to specify if Core is the parent
					aFile << "ParentProfile = ";
					aFile << aSrcEntry.name << std::endl << std::endl;
				}
				aFile.close();
			}
			else
			{
				Dialogs::showError(
					strFormat("Unable to write Profile data to file %s\n",
						aNewEntry.path.c_str()));
				goto retryQuery;
			}
		}
		break;
	}

	if( !profileExists(aNewEntry) )
	{
		Dialogs::showError(strFormat(
			"Failure creating new Profile '%s' (%s)!",
			aNewEntry.name.c_str(), aNewEntry.path.c_str()));
		goto retryQuery;
	}

	setKeyValueInINI(
		sKnownProfiles[0].path, "",
		std::string(kProfileKeyPrefix) + toString(aProfileCanLoadIdx),
		aNewEntry.name);
	sProfilesCanLoad[aProfileCanLoadIdx].push_back(
		getOrAddProfileIdx(aNewEntry));
	size_t aKnownProfilesCount = sKnownProfiles.size();
	generateProfileLoadPriorityList(aProfileCanLoadIdx);
	sAutoProfileIdx = -1;
	setAutoLoadProfile(
		aDialogResult.autoLoadRequested ? aProfileCanLoadIdx : 0);
	if( aDialogResult.autoLoadRequested )
		sAutoProfileIdx = aProfileCanLoadIdx;
	aLastCreatedProfileIdx = aProfileCanLoadIdx;

	if( sNewBaseProfileIdx >= 0 )
	{// Generated a new kResTemplateBase profile
		// Prompt if want to have it set to Auto-launch target app
		tryAddAutoLaunchApp(sNewBaseProfileIdx);
		sNewBaseProfileIdx = -1;
	}

	if( needFirstProfile )
	{
		if( Dialogs::yesNoPrompt(
				"Would you like to edit this Profile now to match your in-game "
				"Key Binds, hotbar, macros, and so on?",
				"Edit new profile") == eResult_Yes )
		{
			userEditProfile(aLastCreatedProfileIdx, true);
		}
		else 
		{
			loadProfile(aProfileCanLoadIdx);
			return true;
		}
	}

	// loop and query again to actually load the new profile
	goto retryQuery;
}


std::string getStr(const std::string& theKey, const std::string& theDefaultValue)
{
	if( ProfileProperty* aProperty = sPropertyMap.find(condense(theKey)) )
	{
		if( !aProperty->val.empty() )
			return aProperty->val;
	}

	return theDefaultValue;
}


int getInt(const std::string& theKey, int theDefaultValue)
{
	return intFromString(
		getStr(theKey, toString(theDefaultValue)));
}


bool getBool(const std::string& theKey, bool theDefaultValue)
{
	const std::string& aString =
		getStr(theKey, (theDefaultValue ? "1" : "0"));

	if( aString.empty() ||
		aString[0] == '0' ||
		aString[0] == 'n' || // no
		aString[0] == 'N' || // No
		aString[0] == 'f' || // false
		aString[0] == 'F' || // False
		(aString[0] == 'O' && aString[1] == 'F') || // OFF
		(aString[0] == 'O' && aString[1] == 'f') || // Off
		(aString[0] == 'o' && aString[1] == 'f') || // off
		aString[0] == '\0' )
	{
		return false;
	}
	return true;
}


float getFloat(const std::string& theKey, float theDefaultValue)
{
	const std::string& theValue = getStr(theKey, toString(theDefaultValue));
	float result = floatFromString(theValue);
	if( theValue[theValue.size()-1] == '%' )
		result /= 100;
	return result;
}


void getAllKeys(const std::string& thePrefix, KeyValuePairs& out)
{
	PropertyMap::IndexVector anIndexSet;
	sPropertyMap.findAllWithPrefix(condense(thePrefix), &anIndexSet);

	#ifndef NDEBUG
	// Unnecessary but nice for debug output - sort to match order added to map
	std::sort(anIndexSet.begin(), anIndexSet.end());
	#endif

	for(size_t i = 0; i < anIndexSet.size(); ++i)
	{
		out.push_back(std::make_pair(
			sPropertyMap.values()[anIndexSet[i]].name.c_str() +
				posAfterPrefix(
					sPropertyMap.values()[anIndexSet[i]].name,
					thePrefix),
			sPropertyMap.values()[anIndexSet[i]].val.c_str()));
	}
}


void setStr(const std::string& theSection,
			const std::string& theValueName,
			const std::string& theValue)
{
	const std::string& aPropertyName = theSection + "/" + theValueName;
	ProfileProperty& aPropertyRef = sPropertyMap.findOrAdd(
		condense(aPropertyName),
		ProfileProperty(aPropertyName, ""));

	// Only change map and write to file if new string is actually different
	if( aPropertyRef.val == theValue )
		return;
	aPropertyRef.val = theValue;

	if( !sLoadedProfileName.empty() )
	{
		setKeyValueInINI(
			profileNameToFilePath(sLoadedProfileName),
			theSection, theValueName, theValue);
	}
}

} // Profile
